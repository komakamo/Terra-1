<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Terraria Clone v15 - GH Pages Ready</title>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none;
            cursor: default;
        }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; pointer-events: auto; cursor: pointer;
        }
        #start-screen h1 { margin: 0 0 20px 0; font-size: 40px; text-shadow: 2px 2px 0 #4caf50; }
        #start-screen p { font-size: 20px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* Hotbar */
        #hotbar { position: absolute; top: 10px; left: 10px; display: flex; gap: 4px; pointer-events: auto; }
        .slot {
            width: 40px; height: 40px; border: 2px solid #444; background: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; position: relative; border-radius: 4px; transition: transform 0.1s;
        }
        .slot:hover { border-color: #fff; background: rgba(80, 80, 80, 0.8); }
        .slot.active { border-color: #ffd700; background: rgba(60, 60, 60, 0.8); transform: scale(1.05); z-index: 10; }
        .slot.selected { border-color: #f44336; box-shadow: 0 0 5px #f44336; } /* Moving item */
        .slot-num { position: absolute; top: 2px; left: 4px; font-size: 10px; color: #aaa; pointer-events: none; }
        .item-count { position: absolute; bottom: 2px; right: 4px; font-size: 11px; color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; pointer-events: none; }
        .item-icon { width: 24px; height: 24px; image-rendering: pixelated; pointer-events: none; }

        /* Objective Panel */
        #objective-panel {
            position: absolute;
            top: 60px; /* Below hotbar */
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #555;
            font-size: 14px;
            max-width: 250px;
            pointer-events: none;
            z-index: 100;
        }

        /* Inventory Screen */
        #inventory-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(12, 12, 20, 0.95); border: 2px solid #445; border-radius: 8px;
            padding: 20px; pointer-events: auto; display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.8); z-index: 2000;
        }
        #inv-grid {
            display: grid; grid-template-columns: repeat(10, 44px); gap: 4px; margin-top: 10px;
        }
        .inv-slot {
            width: 44px; height: 44px; border: 2px solid #444; background: rgba(30, 30, 30, 0.8);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; position: relative; border-radius: 4px;
        }
        .inv-slot:hover { border-color: #fff; background: #444; }
        .inv-slot.selected { border-color: #e91e63; background: #522; }
        .inv-row-sep { grid-column: 1 / -1; height: 10px; } /* Spacing for hotbar row */

        /* Equipment Slot */
        #equip-slot {
            position: absolute; top: 10px; left: 460px;
            width: 40px; height: 40px; border: 2px solid #666; background: rgba(0, 20, 40, 0.6);
            display: flex; justify-content: center; align-items: center;
            border-radius: 4px; pointer-events: auto;
        }
        #equip-label { position: absolute; top: -16px; left: 0; font-size: 10px; color: #aaa; width: 100%; text-align: center; }

        /* Crafting */
        #crafting-menu {
            position: absolute; top: 70px; left: 10px; background: rgba(0, 15, 30, 0.95);
            border: 2px solid #446; border-radius: 8px; padding: 10px; color: white;
            pointer-events: auto; display: none; max-height: 60vh; overflow-y: auto; width: 280px; z-index: 1500;
        }
        .recipe { display: flex; align-items: center; padding: 6px; border-bottom: 1px solid #335; cursor: pointer; }
        .recipe:hover { background: rgba(255, 255, 255, 0.1); }
        .recipe.disabled { opacity: 0.4; cursor: not-allowed; }
        .recipe-icon { width: 24px; height: 24px; margin-right: 10px; border: 1px solid #555; background: rgba(0,0,0,0.3); }
        .recipe-details { flex: 1; font-size: 12px; }

        /* HUD & Stats */
        #hud-info { position: absolute; top: 10px; right: 10px; text-align: right; pointer-events: none; }
        #stats-container { display: flex; flex-direction: column; align-items: flex-end; gap: 2px; margin-bottom: 5px; }
        .bar-row { display: flex; gap: 2px; margin-bottom: 2px; }
        .heart { width: 16px; height: 16px; background-color: #d32f2f; transform: rotate(45deg); box-shadow: inset -1px -1px 1px rgba(0,0,0,0.5); margin: 2px; position: relative; }
        .heart::before, .heart::after { content: ""; width: 16px; height: 16px; background-color: #d32f2f; border-radius: 50%; position: absolute; }
        .heart::before { top: -8px; left: 0; } .heart::after { top: 0; left: -8px; }
        .heart.empty { background-color: #444; } .heart.empty::before, .heart.empty::after { background-color: #444; }
        .star { width: 14px; height: 14px; background-color: #2196f3; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); margin: 1px; }
        .star.empty { background-color: #444; }
        .def-badge { color: #bbb; font-weight: bold; font-size: 14px; text-shadow: 1px 1px 0 #000; margin-top: 4px; }

        /* Boss Bar */
        #boss-bar-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 400px; height: 20px; background: #333; border: 2px solid #000; display: none; }
        #boss-bar-fill { width: 100%; height: 100%; background: #d32f2f; transition: width 0.1s; }
        #boss-name { position: absolute; top: -20px; left: 0; width: 100%; text-align: center; color: #fff; font-weight: bold; text-shadow: 1px 1px 2px #000; }
        
        /* Message Log */
        #msg-log { position: absolute; bottom: 80px; left: 20px; display: flex; flex-direction: column; gap: 4px; pointer-events: none; }
        .msg { color: #fff; text-shadow: 1px 1px 0 #000, 0 0 4px #000; font-size: 16px; opacity: 1; transition: opacity 1s; font-weight: bold; background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; border-left: 3px solid #ffd700; }

        /* Minimap */
        #minimap-container {
            position: absolute; top: 10px; right: 10px; width: 150px; height: 100px;
            border: 2px solid #666; background: rgba(0,0,0,0.8); pointer-events: none; margin-top: 60px; /* below stats */
        }
        #minimapCanvas { width: 100%; height: 100%; display: block; image-rendering: pixelated; }

        /* Tooltip */
        #tooltip {
            position: absolute; pointer-events: none; display: none;
            background: rgba(10, 10, 30, 0.95); border: 2px solid #668; border-radius: 4px;
            padding: 8px; color: #fff; font-size: 12px; z-index: 1000; min-width: 150px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        .tt-title { font-weight: bold; font-size: 14px; color: #ffd700; margin-bottom: 4px; }
        .tt-stat { color: #ccc; }
        .tt-desc { color: #aaa; font-style: italic; margin-top: 4px; }

        /* Icons */
        .icon-acc { border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px #fff; }
        .icon-armor { border: 2px solid #aaa; border-radius: 4px; background: linear-gradient(135deg, #555, #333); }

        /* Error Screen */
        #error-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(100, 0, 0, 0.7); z-index: 10000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            color: white; pointer-events: auto; cursor: pointer;
            backdrop-filter: blur(5px);
        }
        #error-screen h2 { color: #ffdddd; }
        #error-message {
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 5px;
            font-family: 'Courier New', Courier, monospace; white-space: pre-wrap;
            max-width: 80%; max-height: 70vh; overflow-y: auto;
            border-left: 5px solid #f44336;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Error Screen -->
    <div id="error-screen">
        <h2>An unexpected error occurred!</h2>
        <pre id="error-message"></pre>
        <p style="margin-top: 20px;">Click to close.</p>
    </div>
    
    <!-- Added Start Screen for Audio Context compliance -->
    <div id="start-screen">
        <h1>Mini Terraria</h1>
        <p>Click to Start Game</p>
    </div>

    <div id="ui-layer">
        <div id="objective-panel"></div>
        <div id="hotbar"></div>
        <div id="equip-slot" data-type="armor">
            <div id="equip-label">Armor</div>
            <div id="equip-icon"></div>
        </div>

        <div id="inventory-screen">
            <div style="color:#fff; font-weight:bold; margin-bottom:5px;">Inventory</div>
            <div id="inv-grid"></div>
        </div>

        <div id="crafting-menu"><div style="text-align:center; border-bottom:1px solid #fff;">Crafting</div><div id="recipe-list"></div></div>
        
        <div id="hud-info">
            <div id="stats-container">
                <div id="hearts-row" class="bar-row"></div>
                <div id="mana-row" class="bar-row"></div>
            </div>
            <div id="def-display" class="def-badge">Defense: 0</div>
            <div style="color:#ccc; font-size:12px; margin-top:5px; text-shadow:1px 1px 0 #000;">
                [I] Inventory [E] Craft<br>
                [R-Click] Equip/Place
            </div>
        </div>
        
        <div id="minimap-container">
            <canvas id="minimapCanvas"></canvas>
        </div>

        <div id="boss-bar-container">
            <div id="boss-name">Eye of Cthulhu</div>
            <div id="boss-bar-fill"></div>
        </div>
        <div id="msg-log"></div>
        <div id="tooltip"></div>
    </div>

<script>

window.onerror = function(message, source, lineno, colno, error) {
    const errorScreen = document.getElementById('error-screen');
    const errorMessage = document.getElementById('error-message');

    let formattedMessage = `Error: ${message}\n`;
    if (source) {
        formattedMessage += `Source: ${source.split('/').pop()} @ Line ${lineno}:${colno}\n`;
    }
    if (error && error.stack) {
        formattedMessage += `\nStack Trace:\n${error.stack}`;
    }

    errorMessage.textContent = formattedMessage;
    errorScreen.style.display = 'flex';

    // Stop the game loop if possible (assuming `game` is a global or accessible variable)
    // This part might need adjustment depending on the final game structure.
    // For now, we'll just show the screen.

    return true; // Prevents the default browser error handling
};

function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

/** CONSTANTS */
const TILE_SIZE = 32;
const CHUNK_WIDTH = 240;
const CHUNK_HEIGHT = 140;
const GRAVITY = 0.5;
const TERMINAL_VELOCITY = 15;
const PLAYER_SPEED = 4;
const JUMP_FORCE = 9;
const REACH_PX = 6 * TILE_SIZE;
const INV_SIZE = 30; // 3 rows of 10
const TILESET_SOURCES = [
    'assets/tiles.png',
    'assets/images/blocks1.jpg',
    'assets/images/blocks2.jpg'
];

const tilesets = TILESET_SOURCES.map(src => {
    const img = new Image();
    const entry = { img, src, ready: false };
    img.onload = () => entry.ready = true;
    img.onerror = () => console.warn(`Failed to load tileset: ${src}`);
    img.src = src;
    return entry;
});

let activeTilesetIndex = 0;
const getActiveTileset = () => {
    const chosen = tilesets[activeTilesetIndex];
    if (chosen.ready) return chosen;
    return tilesets.find(t => t.ready) || chosen;
};
const cycleTileset = (dir = 1) => {
    const len = tilesets.length;
    for (let i = 1; i <= len; i++) {
        const idx = (activeTilesetIndex + dir * i + len) % len;
        if (tilesets[idx].ready) {
            activeTilesetIndex = idx;
            return tilesets[idx];
        }
    }
    return getActiveTileset();
};

/*
Sprite atlas expectations (replace assets/tiles.png to re-skin):
- 32x32 pixel tiles laid out in grid order.
- Row 0: Dirt, Grass, Stone, Wood, Leaves, Bedrock, Coal Ore, Iron Ore
- Row 1: Gold Ore, Hellstone Ore, Ash, Ebonstone, Corrupt Grass, Cloud, Sand, Cactus
- Row 2: Mud, Mushroom Grass, Glowing Mushroom, Brick, Platform, Water, Lava, Workbench
- Row 3: Furnace, Torch, Life Crystal, Mushroom, Chest, Empty Chest, Closed Door, Open Door
- Row 4: Dirt Wall, Stone Wall, Wood Wall, Brick Wall, Ebonstone Wall
Swap the PNG while keeping this 32px grid to change visuals without code edits.
*/

const IDS = {
    AIR: 0,
    DIRT: 1, GRASS: 2, STONE: 3, WOOD: 4, LEAVES: 5, BEDROCK: 6,
    COAL_ORE: 7, IRON_ORE: 8, GOLD_ORE: 9, HELLSTONE_ORE: 10, ASH: 11,
    BRICK: 12, PLATFORM: 13, WATER: 14, LAVA: 15,
    EBONSTONE: 16, PURPLE_GRASS: 17, CLOUD: 18, DEMONITE_ORE: 19,
    SAND: 30, CACTUS: 31, MUD: 32, MUSHROOM_GRASS: 33,
    
    WORKBENCH: 20, FURNACE: 21, DOOR_CLOSED: 22, DOOR_OPEN: 23,
    TORCH: 25, HEART_CRYSTAL: 26, MUSHROOM: 27, CHEST: 28, CHEST_EMPTY: 29,
    GLOWING_MUSHROOM: 34,
    STONE_BRICK: 35,
    CHEST_HOUSE: 36,
    CHEST_VAULT: 37,

    DIRT_WALL: 50, STONE_WALL: 51, WOOD_WALL: 52, BRICK_WALL: 53, EBON_WALL: 54,

    WOOD_PICK: 100, STONE_PICK: 101, IRON_PICK: 102, GOLD_PICK: 103, NIGHTMARE_PICK: 104,
    WOOD_SWORD: 110, STONE_SWORD: 111, IRON_SWORD: 112, GOLD_SWORD: 113, LIGHTS_BANE: 114,
    MAGIC_STAFF: 120,

    IRON_BAR: 130, GOLD_BAR: 131, HELL_BAR: 132, DEMONITE_BAR: 133, LENS: 134,
    
    DOOR_ITEM: 140, CHEST_ITEM: 141, HEART_ITEM: 142, MUSHROOM_ITEM: 143, EYE_SUMMON: 144,
    GLOWING_MUSHROOM_ITEM: 145, CACTUS_ITEM: 146, SAND_ITEM: 147,

    WOOD_ARMOR: 200, IRON_ARMOR: 201, GOLD_ARMOR: 202, SHADOW_ARMOR: 203,

    BOOTS: 210, CLOUD_BOTTLE: 211
};

const PROPS = {
    [IDS.AIR]: { name:'Air', transparent:true, solid:false },
    [IDS.DIRT]: { name:'Dirt', color:'#5d4037', solid:true, hardness:300, type:'block', sprite:{x:0,y:0} },
    [IDS.GRASS]: { name:'Grass', color:'#388e3c', topColor:'#4caf50', solid:true, hardness:350, type:'block', sprite:{x:1,y:0} },
    [IDS.STONE]: { name:'Stone', color:'#757575', solid:true, hardness:800, reqTool:true, type:'block', sprite:{x:2,y:0} },
    [IDS.ASH]: { name:'Ash', color:'#424242', solid:true, hardness:400, type:'block', sprite:{x:2,y:1} },
    [IDS.BRICK]: { name:'Brick', color:'#8d6e63', solid:true, hardness:900, type:'block', sprite:{x:3,y:2} },
    [IDS.EBONSTONE]: { name:'Ebonstone', color:'#4a148c', solid:true, hardness:1500, reqTool:true, minPower: 50, type:'block', sprite:{x:3,y:1} },
    [IDS.PURPLE_GRASS]: { name:'Corrupt Grass', color:'#4a148c', topColor:'#7b1fa2', solid:true, hardness:500, type:'block', sprite:{x:4,y:1} },
    [IDS.CLOUD]: { name:'Cloud', color:'#ffffff', solid:true, hardness:200, type:'block', sprite:{x:5,y:1} },
    [IDS.WOOD]: { name:'Wood', color:'#795548', solid:true, hardness:500, type:'material', sprite:{x:3,y:0} },
    [IDS.LEAVES]: { name:'Leaves', color:'#2e7d32', solid:true, transparent:true, hardness:100, sprite:{x:4,y:0} },
    [IDS.BEDROCK]: { name:'Bedrock', color:'#222', solid:true, hardness:Infinity, sprite:{x:5,y:0} },
    
    [IDS.SAND]: { name:'Sand', color:'#fdd835', solid:true, hardness:200, type:'block', sprite:{x:6,y:1} },
    [IDS.CACTUS]: { name:'Cactus', color:'#43a047', decor:'cactus', solid:false, hardness:150, sprite:{x:7,y:1} },
    [IDS.MUD]: { name:'Mud', color:'#3e2723', solid:true, hardness:350, type:'block', sprite:{x:0,y:2} },
    [IDS.MUSHROOM_GRASS]: { name:'Mushroom Grass', color:'#1a237e', topColor:'#2979ff', solid:true, hardness:400, light:2, sprite:{x:1,y:2} },
    [IDS.GLOWING_MUSHROOM]: { name:'Glowing Mushroom', color:'#00e5ff', decor:'mushroom_blue', solid:false, light:5, hardness:50, sprite:{x:2,y:2} },
    [IDS.STONE_BRICK]: { name:'Stone Brick', color:'#616161', solid:true, hardness:1000, type:'block', sprite:{x:3,y:2} },

    [IDS.COAL_ORE]: { name:'Coal', color:'#757575', decor:'coal', solid:true, hardness:900, reqTool:true, type:'material', sprite:{x:6,y:0} },
    [IDS.IRON_ORE]: { name:'Iron Ore', color:'#757575', decor:'iron', solid:true, hardness:1200, reqTool:true, minPower: 35, type:'material', sprite:{x:7,y:0} },
    [IDS.GOLD_ORE]: { name:'Gold Ore', color:'#757575', decor:'gold', solid:true, hardness:1500, reqTool:true, minPower: 45, type:'material', sprite:{x:0,y:1} },
    [IDS.DEMONITE_ORE]: { name:'Demonite', color:'#5e35b1', decor:'demonite', solid:true, hardness:2000, reqTool:true, minPower: 55, light:3, type:'material' },
    [IDS.HELLSTONE_ORE]: { name:'Hellstone', color:'#662222', decor:'hell', solid:true, hardness:3000, reqTool:true, minPower: 65, light:4, type:'material', sprite:{x:1,y:1} },
    
    [IDS.PLATFORM]: { name:'Platform', color:'#8d6e63', decor:'platform', platform:true, transparent:true, hardness:100, type:'block', sprite:{x:4,y:2} },
    [IDS.WATER]: { name:'Water', color:'rgba(0, 100, 255, 0.6)', liquid:true, transparent:true, hardness:Infinity, sprite:{x:5,y:2} },
    [IDS.LAVA]: { name:'Lava', color:'rgba(255, 80, 0, 0.8)', liquid:true, transparent:true, hardness:Infinity, light:12, damage:20, sprite:{x:6,y:2} },

    [IDS.WORKBENCH]: { name:'Workbench', color:'#5d4037', decor:'workbench', transparent:true, hardness:300, station:true, type:'station', sprite:{x:7,y:2} },
    [IDS.FURNACE]: { name:'Furnace', color:'#424242', decor:'furnace', transparent:true, hardness:500, station:true, light:5, type:'station', sprite:{x:0,y:3} },
    [IDS.TORCH]: { name:'Torch', color:'#ffcc00', decor:'torch', transparent:true, light:15, hardness:10, type:'placeable', sprite:{x:1,y:3} },
    [IDS.HEART_CRYSTAL]: { name:'Life Crystal', color:'#e91e63', decor:'heart', transparent:true, light:8, hardness:1200, reqTool:true, minPower: 50, sprite:{x:2,y:3} },
    [IDS.MUSHROOM]: { name:'Mushroom', color:'#f44336', decor:'mushroom', transparent:true, hardness:50, sprite:{x:3,y:3} },
    [IDS.CHEST]: { name:'Chest', color:'#ffeb3b', decor:'chest', transparent:true, hardness:Infinity, sprite:{x:4,y:3} },
    [IDS.CHEST_EMPTY]: { name:'Empty Chest', color:'#795548', decor:'chest', transparent:true, hardness:400, sprite:{x:5,y:3} },
    [IDS.CHEST_HOUSE]: { name:'Old Chest', color:'#a1887f', decor:'chest', transparent:true, hardness:Infinity, sprite:{x:4,y:3} },
    [IDS.CHEST_VAULT]: { name:'Gilded Chest', color:'#ffd700', decor:'chest', transparent:true, hardness:Infinity, sprite:{x:4,y:3} },
    [IDS.DOOR_CLOSED]: { name:'Door', color:'#5d4037', decor:'door_c', solid:true, transparent:true, hardness:400, sprite:{x:6,y:3} },
    [IDS.DOOR_OPEN]: { name:'Door', color:'#5d4037', decor:'door_l', transparent:true, hardness:400, sprite:{x:7,y:3} },

    [IDS.DIRT_WALL]: { name:'Dirt Wall', color:'#3e2723', isWall:true, type:'wall', sprite:{x:0,y:4} },
    [IDS.STONE_WALL]: { name:'Stone Wall', color:'#424242', isWall:true, type:'wall', sprite:{x:1,y:4} },
    [IDS.WOOD_WALL]: { name:'Wood Wall', color:'#4e342e', isWall:true, type:'wall', sprite:{x:2,y:4} },
    [IDS.BRICK_WALL]: { name:'Brick Wall', color:'#8d6e63', isWall:true, type:'wall', sprite:{x:3,y:4} },
    [IDS.EBON_WALL]: { name:'Ebonstone Wall', color:'#311b92', isWall:true, type:'wall', sprite:{x:4,y:4} },

    [IDS.WOOD_PICK]: { name:'Wood Pickaxe', type:'tool', power:35, maxStack:1, color:'#795548' },
    [IDS.STONE_PICK]: { name:'Stone Pickaxe', type:'tool', power:40, maxStack:1, color:'#757575' },
    [IDS.IRON_PICK]: { name:'Iron Pickaxe', type:'tool', power:50, maxStack:1, color:'#b0bec5' },
    [IDS.GOLD_PICK]: { name:'Gold Pickaxe', type:'tool', power:55, maxStack:1, color:'#ffd54f' },
    [IDS.NIGHTMARE_PICK]: { name:'Nightmare Pickaxe', type:'tool', power:70, maxStack:1, color:'#5e35b1' },

    [IDS.WOOD_SWORD]: { name:'Wood Sword', type:'weapon', damage:7, maxStack:1, color:'#795548' },
    [IDS.STONE_SWORD]: { name:'Stone Sword', type:'weapon', damage:10, maxStack:1, color:'#757575' },
    [IDS.IRON_SWORD]: { name:'Iron Sword', type:'weapon', damage:14, maxStack:1, color:'#b0bec5' },
    [IDS.GOLD_SWORD]: { name:'Gold Sword', type:'weapon', damage:18, maxStack:1, color:'#ffd54f' },
    [IDS.LIGHTS_BANE]: { name:'Light\'s Bane', type:'weapon', damage:24, maxStack:1, color:'#5e35b1' },
    [IDS.MAGIC_STAFF]: { name:'Magic Staff', type:'magic', damage:18, mana:5, color:'#aa00ff', maxStack:1 },
    
    [IDS.WOOD_ARMOR]: { name:'Wood Armor', type:'armor', def:2, maxStack:1, color:'#795548' },
    [IDS.IRON_ARMOR]: { name:'Iron Armor', type:'armor', def:5, maxStack:1, color:'#b0bec5' },
    [IDS.GOLD_ARMOR]: { name:'Gold Armor', type:'armor', def:8, maxStack:1, color:'#ffd54f' },
    [IDS.SHADOW_ARMOR]: { name:'Shadow Armor', type:'armor', def:12, maxStack:1, color:'#311b92' },

    [IDS.BOOTS]: { name:'Hermes Boots', type:'acc', color:'#00e676', maxStack:1 },
    [IDS.CLOUD_BOTTLE]: { name:'Cloud in a Bottle', type:'acc', color:'#e0f7fa', maxStack:1 },
    
    [IDS.DOOR_ITEM]: { name:'Door', color:'#5d4037', type:'block', placeId:IDS.DOOR_CLOSED },
    [IDS.CHEST_ITEM]: { name:'Chest', color:'#ffeb3b', type:'block', placeId:IDS.CHEST_EMPTY },
    [IDS.HEART_ITEM]: { name:'Life Crystal', color:'#e91e63', type:'use', effect:'maxhp', val:20 },
    [IDS.MUSHROOM_ITEM]: { name:'Mushroom', color:'#f44336', type:'use', effect:'heal', val:15, heal: true },
    [IDS.GLOWING_MUSHROOM_ITEM]: { name:'Glowing Mushroom', color:'#00e5ff', type:'use', effect:'heal', val:25, heal: true },
    [IDS.SAND_ITEM]: { name:'Sand', color:'#fdd835', type:'block', placeId:IDS.SAND },
    [IDS.CACTUS_ITEM]: { name:'Cactus', color:'#43a047', type:'block', placeId:IDS.CACTUS },
    [IDS.EYE_SUMMON]: { name:'Suspicious Eye', color:'#fff', type:'summon' },
    
    [IDS.IRON_BAR]: { name:'Iron Bar', color:'#b0bec5', type:'material' },
    [IDS.GOLD_BAR]: { name:'Gold Bar', color:'#ffd54f', type:'material' },
    [IDS.DEMONITE_BAR]: { name:'Demonite Bar', color:'#5e35b1', type:'material' },
    [IDS.HELL_BAR]: { name:'Hellstone Bar', color:'#a03030', type:'material' },
    [IDS.LENS]: { name:'Lens', color:'#333', type:'material' }
};

const RECIPES = [
    { out:{id:IDS.TORCH, n:3}, in:[{id:IDS.WOOD, n:1}, {id:IDS.COAL_ORE, n:1}] },
    { out:{id:IDS.WORKBENCH, n:1}, in:[{id:IDS.WOOD, n:10}] },
    { out:{id:IDS.FURNACE, n:1}, in:[{id:IDS.STONE, n:20}, {id:IDS.WOOD, n:5}, {id:IDS.TORCH, n:3}], station:IDS.WORKBENCH },
    { out:{id:IDS.PLATFORM, n:2}, in:[{id:IDS.WOOD, n:1}] },
    { out:{id:IDS.WOOD_WALL, n:4}, in:[{id:IDS.WOOD, n:1}], station:IDS.WORKBENCH },
    { out:{id:IDS.DOOR_ITEM, n:1}, in:[{id:IDS.WOOD, n:6}], station:IDS.WORKBENCH },
    { out:{id:IDS.CHEST_ITEM, n:1}, in:[{id:IDS.WOOD, n:8}, {id:IDS.IRON_BAR, n:2}], station:IDS.WORKBENCH },
    
    { out:{id:IDS.IRON_BAR, n:1}, in:[{id:IDS.IRON_ORE, n:3}], station:IDS.FURNACE },
    { out:{id:IDS.GOLD_BAR, n:1}, in:[{id:IDS.GOLD_ORE, n:3}], station:IDS.FURNACE },
    { out:{id:IDS.DEMONITE_BAR, n:1}, in:[{id:IDS.DEMONITE_ORE, n:3}], station:IDS.FURNACE },
    { out:{id:IDS.HELL_BAR, n:1}, in:[{id:IDS.HELLSTONE_ORE, n:3}], station:IDS.FURNACE },

    { out:{id:IDS.WOOD_ARMOR, n:1}, in:[{id:IDS.WOOD, n:25}], station:IDS.WORKBENCH },
    { out:{id:IDS.WOOD_SWORD, n:1}, in:[{id:IDS.WOOD, n:8}], station:IDS.WORKBENCH },
    
    { out:{id:IDS.STONE_PICK, n:1}, in:[{id:IDS.STONE, n:12}, {id:IDS.WOOD, n:4}], station:IDS.WORKBENCH },
    { out:{id:IDS.STONE_SWORD, n:1}, in:[{id:IDS.STONE, n:10}, {id:IDS.WOOD, n:2}], station:IDS.WORKBENCH },

    { out:{id:IDS.IRON_PICK, n:1}, in:[{id:IDS.IRON_BAR, n:10}, {id:IDS.WOOD, n:3}], station:IDS.FURNACE },
    { out:{id:IDS.IRON_SWORD, n:1}, in:[{id:IDS.IRON_BAR, n:8}], station:IDS.FURNACE },
    { out:{id:IDS.IRON_ARMOR, n:1}, in:[{id:IDS.IRON_BAR, n:20}], station:IDS.FURNACE },

    { out:{id:IDS.GOLD_PICK, n:1}, in:[{id:IDS.GOLD_BAR, n:10}, {id:IDS.WOOD, n:3}], station:IDS.FURNACE },
    { out:{id:IDS.GOLD_SWORD, n:1}, in:[{id:IDS.GOLD_BAR, n:8}], station:IDS.FURNACE },
    { out:{id:IDS.GOLD_ARMOR, n:1}, in:[{id:IDS.GOLD_BAR, n:20}], station:IDS.FURNACE },

    { out:{id:IDS.NIGHTMARE_PICK, n:1}, in:[{id:IDS.DEMONITE_BAR, n:12}, {id:IDS.LENS, n:2}], station:IDS.FURNACE },
    { out:{id:IDS.LIGHTS_BANE, n:1}, in:[{id:IDS.DEMONITE_BAR, n:10}], station:IDS.FURNACE },
    { out:{id:IDS.SHADOW_ARMOR, n:1}, in:[{id:IDS.DEMONITE_BAR, n:25}], station:IDS.FURNACE },

    { out:{id:IDS.EYE_SUMMON, n:1}, in:[{id:IDS.LENS, n:6}], station:IDS.WORKBENCH },
];

const OBJECTIVES = [
    {
        text: "木材を10個集めて、ワークベンチを作ろう。",
        condition: (game) => {
            const hasItem = game.player.inv.some(i => i.id === IDS.WORKBENCH);
            // This check is slow, but acceptable for this case.
            const isPlaced = game.world.some(row => row.includes(IDS.WORKBENCH));
            return hasItem || isPlaced;
        }
    },
    {
        text: "ワークベンチの近くでかまどを作ろう。\n(石x20, 木材x5, 松明x3)",
        condition: (game) => {
            const hasItem = game.player.inv.some(i => i.id === IDS.FURNACE);
            const isPlaced = game.world.some(row => row.includes(IDS.FURNACE));
            return hasItem || isPlaced;
        }
    },
    {
        text: "家を建ててガイドを住まわせよう。\n([H]キーで家の有効性を確認)",
        condition: (game) => {
            // Assumes checkHousing is modified to return a boolean
            return game.checkHousing(true);
        }
    },
    {
        text: "鉄か金の装備を整えて、最初のボスを倒そう。",
        condition: (game) => {
            return game.flags && game.flags.boss1Defeated;
        }
    },
    {
        text: "目的達成！おめでとう！",
        condition: (game) => false // This objective doesn't auto-complete
    }
];

class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 
        this.masterGain.connect(this.ctx.destination);
    }
    
    play(type) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.masterGain);
        const now = this.ctx.currentTime;

        if (type === 'jump') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(300, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'dig') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(600, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(now); osc.stop(now + 0.15);
        } else if (type === 'pickup') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1000, now);
            osc.frequency.linearRampToValueAtTime(1500, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'swing') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        }
    }
}

class Particle {
    constructor(x, y, color, speed, life=1.0) {
        this.x=x; this.y=y; this.color=color;
        this.vx=(Math.random()-0.5)*speed; this.vy=(Math.random()-0.5)*speed;
        this.life=life; this.decay=0.03+Math.random()*0.02; this.size=Math.random()*3+2;
    }
    update() { this.x+=this.vx; this.y+=this.vy; this.vy+=0.2; this.life-=this.decay; }
    draw(ctx, cx, cy) {
        ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color;
        ctx.fillRect(this.x-cx, this.y-cy, this.size, this.size); ctx.globalAlpha=1.0;
    }
}

class TextEffect {
    constructor(x, y, text, color) { this.x=x; this.y=y; this.text=text; this.color=color; this.vy=-1; this.life=1.0; }
    update() { this.y+=this.vy; this.life-=0.015; }
    draw(ctx, cx, cy) {
        ctx.globalAlpha=Math.max(0, this.life); ctx.fillStyle=this.color;
        ctx.font='bold 14px monospace'; ctx.strokeStyle='black'; ctx.lineWidth=2;
        ctx.strokeText(this.text, this.x-cx, this.y-cy); ctx.fillText(this.text, this.x-cx, this.y-cy);
        ctx.globalAlpha=1.0;
    }
}

class Projectile {
    constructor(x, y, vx, vy, damage, color) {
        this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.damage=damage; this.color=color;
        this.life=60; this.dead=false;
    }
    update(world, enemies, particles, texts, game) {
        this.life--; this.x+=this.vx; this.y+=this.vy;
        if(Math.random()<0.5) particles.push(new Particle(this.x, this.y, this.color, 1, 0.5));
        const gx=Math.floor(this.x/TILE_SIZE), gy=Math.floor(this.y/TILE_SIZE);
        if(gx>=0 && gx<CHUNK_WIDTH && gy>=0 && gy<CHUNK_HEIGHT && PROPS[world[gy][gx]].solid) {
            this.dead=true; for(let i=0;i<3;i++) particles.push(new Particle(this.x, this.y, this.color, 3));
            game.sound.play('dig');
        }
        for(let e of enemies) {
            if(!e.dead && Math.abs(e.x+e.w/2 - this.x)<e.w/2+5 && Math.abs(e.y+e.h/2 - this.y)<e.h/2+5) {
                e.takeDamage(this.damage, this.x, particles, texts, game); this.dead=true; break;
            }
        }
        if(this.life<=0) this.dead=true;
    }
    draw(ctx, cx, cy) { ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x-cx, this.y-cy, 4, 0, Math.PI*2); ctx.fill(); }
}

class Entity {
    constructor(x, y, type) {
        this.x=x; this.y=y; this.type=type; this.dead=false; this.vx=0; this.vy=0; this.grounded=false; this.flash=0;
        if(type==='slime') { this.w=24; this.h=18; this.hp=40; this.color='#2196f3'; this.dmg=8; }
        else if(type==='zombie') { this.w=20; this.h=36; this.hp=60; this.color='#4caf50'; this.dmg=12; }
        else if(type==='eye') { this.w=24; this.h=24; this.hp=40; this.color='#e53935'; this.dmg=10; this.fly=true; }
        else if(type==='eater') { this.w=28; this.h=28; this.hp=50; this.color='#7b1fa2'; this.dmg=15; this.fly=true; }
        else if(type==='boss') { this.w=60; this.h=60; this.hp=2000; this.maxHp=2000; this.color='#eee'; this.dmg=25; this.fly=true; this.boss=true; }
        else if(type==='servant') { this.w=16; this.h=16; this.hp=15; this.color='#e53935'; this.dmg=8; this.fly=true; }
        else if(type==='npc_guide') { this.w=20; this.h=36; this.hp=250; this.color='#ffeb3b'; this.dmg=0; this.friendly=true; }
        this.phase=1; this.timer=0; this.dir=1;
    }
    update(world, p, particles, texts, isNight, game) {
        if(this.dead) return;
        const dx = p.x+p.w/2-(this.x+this.w/2), dy = p.y+p.h/2-(this.y+this.h/2);
        const dist = Math.hypot(dx, dy);
        if(dist>1800 && !this.boss && !this.friendly) this.dead=true;
        if(this.boss && !isNight) { this.dead=true; return; }

        if(this.friendly) {
            if(this.grounded) {
                const absDist = Math.abs(p.x - this.x);
                if(absDist > 60 && absDist < 400) {
                    this.vx = (p.x > this.x ? 1 : -1) * 2; this.dir = (p.x > this.x ? 1 : -1);
                } else this.vx *= 0.8;
                if(this.wallInFront(world, this.dir)) this.vy = -7;
            }
        } else if(this.type==='slime') {
            if(this.grounded) {
                this.vx*=0.8; this.timer--;
                if(this.timer<=0) { this.vx=(dx>0?1:-1)*(2+Math.random()); this.vy=-6-Math.random()*3; this.timer=60+Math.random()*60; }
            }
        } else if(this.type==='zombie') {
            this.vx = (dx>0?1:-1)*1.5; if(this.grounded && this.wallInFront(world, dx>0?1:-1)) this.vy=-7;
        } else if(this.type==='eye'||this.type==='servant') {
            let spd = this.type==='servant'?3:2.5; let a = Math.atan2(dy, dx);
            this.vx = Math.cos(a)*spd; this.vy = Math.sin(a)*spd; this.vx*=0.95; this.vy*=0.95;
        } else if(this.type==='eater') {
            let a = Math.atan2(dy, dx); this.vx += Math.cos(a)*0.1; this.vy += Math.sin(a)*0.1;
            let spd = Math.hypot(this.vx, this.vy); if(spd>4) { this.vx=(this.vx/spd)*4; this.vy=(this.vy/spd)*4; }
        } else if(this.type==='boss') {
            this.timer++;
            if(this.hp < this.maxHp*0.5) this.phase=2;
            if(this.phase===1) {
                let tx=p.x, ty=p.y-200;
                this.vx+=(tx-this.x)*0.005; this.vy+=(ty-this.y)*0.005;
                if(this.timer%200===0) game.enemies.push(new Entity(this.x, this.y, 'servant'));
            } else {
                if(this.timer%120<40) { if(this.timer%120===0) { let a=Math.atan2(dy,dx); this.vx=Math.cos(a)*12; this.vy=Math.sin(a)*12; } }
                else { this.vx*=0.9; this.vy*=0.9; }
            }
            let limit = this.phase===1?6:15;
            this.vx=Math.max(-limit,Math.min(limit,this.vx)); this.vy=Math.max(-limit,Math.min(limit,this.vy));
        }

        if(!this.fly) this.vy+=GRAVITY;
        this.x+=this.vx; this.collide(world, true);
        this.y+=this.vy; this.grounded=false; this.collide(world, false);
        if(this.y>CHUNK_HEIGHT*TILE_SIZE) { if(!this.friendly) this.dead=true; else { this.x=p.x; this.y=p.y; } }
        if(this.flash>0) this.flash--;
        if(!this.dead && !this.friendly && this.rectCollide(p)) p.hit(this.dmg, this.x);
    }
    wallInFront(world, dir) {
        let tx=Math.floor((this.x+this.w/2+dir*20)/TILE_SIZE), ty=Math.floor((this.y+this.h-5)/TILE_SIZE);
        return (tx>=0&&tx<CHUNK_WIDTH&&ty>=0&&ty<CHUNK_HEIGHT&&PROPS[world[ty][tx]].solid);
    }
    collide(world, isX) {
        if(this.fly) return;
        const l=Math.floor(this.x/32), r=Math.floor((this.x+this.w)/32), t=Math.floor(this.y/32), b=Math.floor((this.y+this.h)/32);
        const getP = (x,y) => { if(x>=0 && x<CHUNK_WIDTH && y>=0 && y<CHUNK_HEIGHT) return PROPS[world[y][x]]; return null; };
        if (isX) {
            for (let y = t; y <= b; y++) {
                let pR = getP(r, y);
                if (this.vx > 0 && pR && pR.solid) {
                    this.x = r * 32 - this.w - 0.1;
                    this.vx = 0;
                    break;
                }
                let pL = getP(l, y);
                if (this.vx < 0 && pL && pL.solid) {
                    this.x = (l + 1) * 32 + 0.1;
                    this.vx = 0;
                    break;
                }
            }
        } else {
            if(this.vy>0) {
                let pL=getP(l,b), pR=getP(r,b);
                if((pL&&pL.solid)||(pR&&pR.solid)) { if(this.y+this.h <= b*32+12) { this.y=b*32-this.h; this.vy=0; this.grounded=true; } }
                // NPCs/Enemies don't have key state, so they can't drop down platforms.
                // Player platform logic is handled separately in Game.prototype.collide.
                else if((pL&&pL.platform)||(pR&&pR.platform)) { if(this.y+this.h <= b*32+12) { this.y=b*32-this.h; this.vy=0; this.grounded=true; } }
            }
            else if(this.vy<0) {
                let pL=getP(l,t), pR=getP(r,t);
                if((pL&&pL.solid)||(pR&&pR.solid)) { this.y=(t+1)*32; this.vy=0; }
            }
        }
    }
    rectCollide(p) { return this.x<p.x+p.w && this.x+this.w>p.x && this.y<p.y+p.h && this.y+this.h>p.y; }
    takeDamage(d, fx, parts, texts, game) {
        this.hp-=d; this.flash=10; this.vx=(this.x-fx>0?1:-1)*(this.fly?2:4); this.vy=-3;
        texts.push(new TextEffect(this.x, this.y, d, '#fff'));
        game.hitStop = 4; game.sound.play('hit');
        if(this.hp<=0) {
            this.dead=true; for(let i=0;i<6;i++) parts.push(new Particle(this.x+this.w/2, this.y+this.h/2, this.color, 5));
            if(this.type==='boss') {
                game.flags.boss1Defeated = true; // Set flag for objective
                texts.push(new TextEffect(this.x, this.y-30, "The spirits of darkness and light have been released.", '#a000e5'));
                game.triggerHardmode();
            }
        }
    }
    draw(ctx, cx, cy) {
        if(this.dead) return;
        ctx.fillStyle = this.flash>0?'#fff':this.color;
        if(this.type==='npc_guide') {
            const x = this.x-cx, y = this.y-cy;
            ctx.save();
            if(this.dir===-1) { ctx.translate(x+10, y+18); ctx.scale(-1,1); ctx.translate(-(x+10), -(y+18)); }
            ctx.fillStyle='#5d4037'; ctx.fillRect(x+4, y+22, 6, 14); ctx.fillRect(x+10, y+22, 6, 14);
            ctx.fillStyle='#795548'; ctx.fillRect(x, y+10, this.w, 14);
            ctx.fillStyle='#ffcc80'; ctx.fillRect(x+2, y-2, 16, 14);
            ctx.fillStyle='#4e342e'; ctx.fillRect(x+2, y-6, 16, 6); ctx.fillRect(x, y-2, 4, 8);
            ctx.restore();
        } else if(this.type==='boss') {
            ctx.beginPath(); ctx.arc(this.x-cx+30, this.y-cy+30, 30, 0, Math.PI*2); ctx.fill();
            if(this.phase===1) { ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.x-cx+30, this.y-cy+30, 10, 0, Math.PI*2); ctx.fill(); }
            else { ctx.fillStyle='#900'; ctx.beginPath(); ctx.arc(this.x-cx+30, this.y-cy+30, 10, 0, Math.PI*2); ctx.fill(); }
        } else if(this.type==='eye'||this.type==='servant') {
            ctx.beginPath(); ctx.arc(this.x-cx+this.w/2, this.y-cy+this.h/2, this.w/2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.x-cx+this.w/2, this.y-cy+this.h/2, 4, 0, Math.PI*2); ctx.fill();
        } else if(this.type==='eater') {
            ctx.beginPath(); ctx.arc(this.x-cx+14, this.y-cy+14, 14, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#4a148c'; ctx.fillRect(this.x-cx-5, this.y-cy+10, 38, 8);
        } else {
            ctx.fillRect(this.x-cx, this.y-cy, this.w, this.h);
        }
    }
}

class Game {
    constructor() {
        this.c = document.getElementById('gameCanvas'); this.ctx = this.c.getContext('2d');
        this.miniC = document.getElementById('minimapCanvas'); this.miniCtx = this.miniC.getContext('2d');
        this.resize();
        this.world = []; this.walls = []; this.light = []; this.parts = []; this.texts = []; this.enemies = []; this.projs = [];
        
        // Sound
        this.sound = new SoundManager();

        // Expanded Inventory
        let startInv = [
            {id:IDS.WOOD_PICK, n:1}, {id:IDS.WOOD_SWORD, n:1}, {id:IDS.TORCH, n:10},
            {id:IDS.WOOD, n:0}, {id:IDS.DIRT, n:0}, {id:IDS.AIR, n:0}, {id:IDS.AIR, n:0}, {id:IDS.AIR, n:0}, {id:IDS.AIR, n:0}
        ];
        // Fill rest with AIR
        for(let i=startInv.length; i<INV_SIZE; i++) startInv.push({id:IDS.AIR, n:0});

        this.player = {
            x:0, y:0, w:20, h:36, vx:0, vy:0, grounded:false, dir:1, frame:0,
            hp:100, maxHp:100, mana:20, maxMana:20, invin:0, respawn:{x:0,y:0}, swing:0,
            def: 0,
            inv: startInv,
            armor: null, sel:0, canDoubleJump: false, hasBoots: false, jumps: 0
        };
        
        this.cam = {x:0, y:0}; this.keys = {}; this.mouse = {x:0, y:0, l:false, r:false};
        this.mining = {on:false, x:-1, y:-1, t:0, dur:0}; 
        this.ui = { craft:false, inv:false };
        this.invCursor = null; // Slot index selected for swapping

        this.time = 6000; this.dayLen = 24000; this.updLight = true; this.wTimer = 0;
        this.hitStop = 0;

        // Objective System
        this.currentObjectiveIndex = 0;
        this.flags = {}; // For story flags like boss kills

        this.init();
        if(!this.loadGame()) { this.genWorld(); } else { this.log("Game Loaded!"); }
        
        // Init minimap size
        this.miniC.width = CHUNK_WIDTH; this.miniC.height = CHUNK_HEIGHT;
        
        this.updateObjectivePanel(); // Initial objective display
        this.uiUpd(); this.loop();
    }

    updateObjectivePanel() {
        const panel = document.getElementById('objective-panel');
        if (this.currentObjectiveIndex < OBJECTIVES.length) {
            panel.innerText = OBJECTIVES[this.currentObjectiveIndex].text;
            panel.style.display = 'block';
        } else {
            panel.style.display = 'none';
        }
    }

    generateTreasureVault() {
        const minX = Math.floor(CHUNK_WIDTH * 0.2);
        const maxX = Math.floor(CHUNK_WIDTH * 0.8);
        const minY = Math.floor(CHUNK_HEIGHT * 0.5);
        const maxY = Math.floor(CHUNK_HEIGHT * 0.8);
        const searchAttempts = 50;

        for (let i = 0; i < searchAttempts; i++) {
            const x = minX + Math.floor(Math.random() * (maxX - minX));
            const y = minY + Math.floor(Math.random() * (maxY - minY));

            if (this.world[y][x] === IDS.AIR) {
                const w = 7 + Math.floor(Math.random() * 4);
                const h = 6 + Math.floor(Math.random() * 3);
                const startX = x - Math.floor(w / 2);
                const startY = y - Math.floor(h / 2);

                for (let j = startY; j < startY + h; j++) {
                    for (let k = startX; k < startX + w; k++) {
                        this.world[j][k] = IDS.STONE_BRICK;
                    }
                }
                for (let j = startY + 1; j < startY + h - 1; j++) {
                    for (let k = startX + 1; k < startX + w - 1; k++) {
                        this.world[j][k] = IDS.AIR;
                    }
                }

                const chestX = startX + Math.floor(w / 2);
                const chestY = startY + h - 2;
                this.world[chestY][chestX] = IDS.CHEST_VAULT;

                // Simple trap
                this.world[chestY - 2][chestX] = IDS.LAVA;
                this.world[chestY - 1][chestX] = IDS.SAND;

                return;
            }
        }
    }

    checkObjectiveCompletion() {
        if (this.currentObjectiveIndex >= OBJECTIVES.length) return;

        const current = OBJECTIVES[this.currentObjectiveIndex];
        if (current.condition(this)) {
            this.currentObjectiveIndex++;
            this.log("目的達成！");
            this.updateObjectivePanel();
        }
    }
    
    resize() { this.w=window.innerWidth; this.h=window.innerHeight; this.c.width=this.w; this.c.height=this.h; this.ctx.imageSmoothingEnabled=false; }
    
    init() {
        window.onresize=()=>this.resize();
        window.onkeydown=e=>{ 
            this.keys[e.code]=true; 
            if(e.key>='1'&&e.key<='9') { this.player.sel=parseInt(e.key)-1; this.uiUpd(); } 
            if(e.code==='KeyE') {
                if(this.ui.inv) this.toggleInv(); // Close inv if open
                else this.interact();
            }
            if(e.code==='KeyH') this.checkHousing();
            if(e.code==='KeyT') {
                const ts = cycleTileset();
                const label = ts?.src?.split('/').pop() || 'Tileset';
                this.log(`Tileset switched to ${label}${ts.ready ? '' : ' (loading...)'}`);
            }
            if(e.code==='Space') this.jump();
            if(e.code==='F5') this.saveGame();
            if(e.code==='F9') { if(this.loadGame()) this.log("Game Loaded!"); }
            if(e.code==='KeyI') this.toggleInv();
            if(e.code==='Escape') { this.ui.inv=false; this.ui.craft=false; document.getElementById('inventory-screen').style.display='none'; document.getElementById('crafting-menu').style.display='none'; }
        };
        window.onkeyup=e=> {
            this.keys[e.code]=false;
            if(e.code==='Space' && this.player.vy < -2) this.player.vy *= 0.5;
        };
        
        // Tooltip Handler
        window.addEventListener('mousemove', (e) => {
            this.mouse.x=e.clientX; this.mouse.y=e.clientY;
            this.updateTooltip(e);
        });

        this.c.onmousedown=e=>{ 
            if(this.ui.inv) return; // Block game interaction when inv open
            if(e.button===0){this.mouse.l=true;this.clickL();} if(e.button===2){this.mouse.r=true;this.clickR();} 
        };
        this.c.onmouseup=e=>{ if(e.button===0){this.mouse.l=false;this.mining.on=false;} if(e.button===2)this.mouse.r=false; };
        this.c.oncontextmenu=e=>e.preventDefault();
    }
    
    log(txt) {
        const d = document.createElement('div'); d.className='msg'; d.innerText=txt;
        document.getElementById('msg-log').appendChild(d);
        setTimeout(()=>d.style.opacity=0, 3000); setTimeout(()=>d.remove(), 4000);
    }

    _generateTooltipHTML(p) {
        let html = `<div class="tt-title">${p.name}</div>`;
        if(p.damage) html += `<div class="tt-stat">Melee Damage: ${p.damage}</div>`;
        if(p.power) html += `<div class="tt-stat">Pickaxe Power: ${p.power}%</div>`;
        if(p.def) html += `<div class="tt-stat">Defense: ${p.def}</div>`;
        if(p.heal) html += `<div class="tt-stat">Restores ${p.val} HP</div>`;
        if(p.type === 'material') html += `<div class="tt-desc">Material</div>`;
        if(p.placeId) html += `<div class="tt-desc">Can be placed</div>`;
        if(p.station) html += `<div class="tt-desc">Crafting Station</div>`;
        return html;
    }

    updateTooltip(e) {
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const tt = document.getElementById('tooltip');
        if(el && (el.classList.contains('slot') || el.classList.contains('inv-slot') || el.id==='equip-slot')) {
            let item = null;
            if(el.classList.contains('slot')) {
                // Hotbar
                let idx = parseInt(el.querySelector('.slot-num').innerText)-1;
                item = this.player.inv[idx];
            } else if(el.classList.contains('inv-slot')) {
                // Inventory
                let idx = parseInt(el.dataset.idx);
                item = this.player.inv[idx];
            } else if(el.id==='equip-slot' && this.player.armor) {
                item = {id: this.player.armor};
            }

            if(item && item.id !== IDS.AIR) {
                const p = PROPS[item.id];
                tt.innerHTML = this._generateTooltipHTML(p);
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY + 15) + 'px';
                return;
            }
        }
        tt.style.display = 'none';
    }

    toggleInv() {
        this.ui.inv = !this.ui.inv;
        document.getElementById('inventory-screen').style.display = this.ui.inv ? 'block' : 'none';
        if(this.ui.inv) {
            this.ui.craft = false; 
            document.getElementById('crafting-menu').style.display = 'none';
            this.renderInventoryScreen();
        }
        this.invCursor = null; // Reset selection
    }

    renderInventoryScreen() {
        const grid = document.getElementById('inv-grid');
        grid.innerHTML = '';
        this.player.inv.forEach((s, i) => {
            const d = document.createElement('div');
            d.className = 'inv-slot' + (this.invCursor === i ? ' selected' : '');
            d.dataset.idx = i;
            d.onclick = () => this.handleInvClick(i);
            
            if(s.id !== IDS.AIR) {
                const p = PROPS[s.id];
                const ic = document.createElement('div'); ic.className='item-icon';
                ic.style.backgroundColor = p.color;
                if(p.type==='tool'||p.type==='weapon') ic.style.mask = 'linear-gradient(45deg, transparent 40%, #000 40%, #000 60%, transparent 60%)'; // rough visual
                
                // Icon Logic (Same as hotbar)
                if(p.type==='tool') ic.className+=' icon-pickaxe';
                else if(p.type==='weapon') ic.className+=' icon-sword';
                else if(p.type==='acc') ic.className+=' icon-acc';
                else if(p.type==='armor') ic.className+=' icon-armor';
                else { ic.style.backgroundColor=p.color; }

                d.appendChild(ic);
                if(p.maxStack!==1) {
                    const cn = document.createElement('div'); cn.className='item-count'; cn.innerText = s.n;
                    d.appendChild(cn);
                }
            }
            grid.appendChild(d);
        });
    }

    handleInvClick(idx) {
        if (this.invCursor === null) {
            // Select
            if(this.player.inv[idx].id !== IDS.AIR) {
                this.invCursor = idx;
            }
        } else {
            // Swap
            const temp = this.player.inv[this.invCursor];
            this.player.inv[this.invCursor] = this.player.inv[idx];
            this.player.inv[idx] = temp;
            this.invCursor = null;
            this.uiUpd(); // Update hotbar too
        }
        this.renderInventoryScreen();
    }

    drawMinimap() {
        // Simple full world redraw to canvas (optimization: could be partial)
        const id = this.miniCtx.createImageData(CHUNK_WIDTH, CHUNK_HEIGHT);
        const d = id.data;
        for(let y=0; y<CHUNK_HEIGHT; y++) {
            for(let x=0; x<CHUNK_WIDTH; x++) {
                let i = (y * CHUNK_WIDTH + x) * 4;
                let t = this.world[y][x];
                let w = this.walls[y][x];
                let color = [0,0,0,0]; // default sky (handled by CSS bg really, but here transparent)
                
                if(t !== IDS.AIR) {
                    // Block color
                    let cStr = PROPS[t].color;
                    // Very simple parsing for named colors or hex (rough approximation for minimap)
                    if(cStr.startsWith('#')) {
                        let r = parseInt(cStr.substr(1,2), 16);
                        let g = parseInt(cStr.substr(3,2), 16);
                        let b = parseInt(cStr.substr(5,2), 16);
                        color = [r,g,b,255];
                    } else if(cStr.startsWith('rgba')) {
                        color = [50, 50, 200, 200]; // Water approx
                    }
                } else if (w !== IDS.AIR) {
                    // Wall color (darker)
                    let cStr = PROPS[w].color;
                    if(cStr.startsWith('#')) {
                        let r = parseInt(cStr.substr(1,2), 16);
                        let g = parseInt(cStr.substr(3,2), 16);
                        let b = parseInt(cStr.substr(5,2), 16);
                        color = [r*0.5, g*0.5, b*0.5, 255];
                    }
                }

                d[i] = color[0]; d[i+1] = color[1]; d[i+2] = color[2]; d[i+3] = color[3];
            }
        }
        
        // Draw Player dot
        let px = Math.floor(this.player.x/TILE_SIZE);
        let py = Math.floor(this.player.y/TILE_SIZE);
        let pi = (py * CHUNK_WIDTH + px) * 4;
        d[pi] = 0; d[pi+1] = 255; d[pi+2] = 0; d[pi+3] = 255; // Green dot

        this.miniCtx.putImageData(id, 0, 0);
    }

    saveGame() {
        const data = { world: this.world, walls: this.walls, player: this.player, time: this.time, enemies: this.enemies.map(e => ({ x:e.x, y:e.y, type:e.type, hp:e.hp, dead:e.dead, phase:e.phase })) };
        try { localStorage.setItem('miniTerrariaSave', JSON.stringify(data)); this.log("Game Saved!"); } catch(e) { this.log("Save failed"); }
    }

    loadGame() {
        const raw = localStorage.getItem('miniTerrariaSave'); if(!raw) return false;
        try {
            const d = JSON.parse(raw); this.world = d.world; this.walls = d.walls; this.player = d.player; this.time = d.time || 6000;
            // Ensure inv size compatibility
            while(this.player.inv.length < INV_SIZE) this.player.inv.push({id:IDS.AIR, n:0});
            
            this.enemies = []; if(d.enemies) d.enemies.forEach(e => { if(!e.dead) { const ent = new Entity(e.x, e.y, e.type); ent.hp = e.hp; ent.phase = e.phase; this.enemies.push(ent); } });
            this.calcLight(); this.uiUpd(); return true;
        } catch(e) { console.error(e); return false; }
    }

    triggerHardmode() {
        this.log("Demonite Ore has appeared underground!");
        for(let i=0; i<100; i++) {
            let x = Math.floor(Math.random()*CHUNK_WIDTH); let y = Math.floor(Math.random()*CHUNK_HEIGHT);
            if(y > 40 && this.world[y][x] === IDS.STONE) {
                this.world[y][x] = IDS.DEMONITE_ORE;
                if(x+1<CHUNK_WIDTH) this.world[y][x+1]=IDS.DEMONITE_ORE; if(y+1<CHUNK_HEIGHT) this.world[y+1][x]=IDS.DEMONITE_ORE;
            }
        }
        this.updLight = true;
    }

    genWorld() {
        this.world = new Array(CHUNK_HEIGHT).fill(0).map(()=>new Array(CHUNK_WIDTH).fill(IDS.AIR));
        this.walls = new Array(CHUNK_HEIGHT).fill(0).map(()=>new Array(CHUNK_WIDTH).fill(IDS.AIR));
        this.light = new Array(CHUNK_HEIGHT).fill(0).map(()=>new Array(CHUNK_WIDTH).fill(0));
        let hMap = []; let h = CHUNK_HEIGHT*0.3;
        for(let x=0;x<CHUNK_WIDTH;x++) { h+=Math.random()*2-1; hMap.push(h); }
        for(let i=0;i<3;i++) for(let x=1;x<CHUNK_WIDTH-1;x++) hMap[x]=(hMap[x-1]+hMap[x]+hMap[x+1])/3;

        let corruptX = Math.floor(Math.random()*(CHUNK_WIDTH-60))+30;
        let desertX = Math.floor(Math.random()*(CHUNK_WIDTH-40))+20;
        if(Math.abs(desertX - corruptX) < 40) desertX = (corruptX + 50) % (CHUNK_WIDTH-40);

        let hellY = CHUNK_HEIGHT - 20;
        let cavernY = CHUNK_HEIGHT * 0.6;
        let underY = CHUNK_HEIGHT * 0.35;
        let mushX = Math.floor(Math.random()*(CHUNK_WIDTH-40))+20;
        let mushY = Math.floor(Math.random()*(cavernY - underY) + underY + 10);

        for(let x=0; x<CHUNK_WIDTH; x++) {
            let sY = Math.floor(hMap[x]);
            let isCorr = (x > corruptX && x < corruptX + 40);
            let isDesert = (x > desertX && x < desertX + 30);
            let chasm = isCorr && Math.abs(x - (corruptX+20)) < 5;

            for(let y=0; y<CHUNK_HEIGHT; y++) {
                if(y>=hellY) {
                    if(y===CHUNK_HEIGHT-1) this.world[y][x]=IDS.BEDROCK;
                    else this.world[y][x] = (Math.random()<0.4)?IDS.ASH:IDS.LAVA;
                    if(Math.random()<0.05 && this.world[y][x]===IDS.ASH) this.world[y][x]=IDS.HELLSTONE_ORE;
                    continue;
                }
                if(y>=sY) {
                    if (x > mushX && x < mushX+30 && y > mushY && y < mushY+20) {
                         if(Math.random()<0.7) {
                             this.world[y][x] = IDS.MUD;
                             if (this.world[y-1][x]===IDS.AIR) this.world[y][x] = IDS.MUSHROOM_GRASS;
                             if (this.world[y][x]===IDS.MUSHROOM_GRASS && Math.random()<0.1) this.world[y-1][x]=IDS.GLOWING_MUSHROOM;
                         } continue;
                    }
                    if(isCorr) {
                        if(chasm && y < sY + 40) { this.walls[y][x] = IDS.EBON_WALL; } 
                        else { this.world[y][x] = IDS.EBONSTONE; this.walls[y][x] = IDS.EBON_WALL; }
                        if(y===sY && !chasm) this.world[y][x] = IDS.PURPLE_GRASS;
                    } else if (isDesert) {
                        this.world[y][x] = IDS.SAND;
                        if (y===sY && Math.random()<0.05) this.world[y-1][x] = IDS.CACTUS;
                    } else {
                        if (y > cavernY) { 
                             this.walls[y][x] = IDS.STONE_WALL; this.world[y][x] = IDS.STONE;
                             if(Math.random()<0.04) this.world[y][x]=IDS.GOLD_ORE;
                        } else if (y > underY) {
                             this.walls[y][x] = (Math.random()<0.5) ? IDS.DIRT_WALL : IDS.STONE_WALL;
                             this.world[y][x] = (Math.random()<0.6) ? IDS.STONE : IDS.DIRT;
                             if(Math.random()<0.03) this.world[y][x]=IDS.IRON_ORE;
                        } else {
                             this.walls[y][x] = IDS.DIRT_WALL; this.world[y][x] = IDS.DIRT;
                             if(y===sY) this.world[y][x]=IDS.GRASS;
                        }
                        if(y>sY+10 && Math.random()<0.01) this.world[y][x]=IDS.COAL_ORE;
                    }
                }
                if(y===sY && !isCorr && !isDesert) { if(Math.random()<0.1) this.genTree(x,y); }
            }
        }
        for(let i=0; i<15; i++) {
            let wx = Math.floor(Math.random() * CHUNK_WIDTH); let wy = Math.floor(Math.random() * (hellY - cavernY) + cavernY);
            this.genPool(wx, wy);
        }
        for(let i=0;i<30;i++) this.worm(Math.random()*CHUNK_WIDTH, hMap[0]+20+Math.random()*60, 50+Math.random()*100);
        let skyX = Math.floor(Math.random()*(CHUNK_WIDTH-40))+20;
        for(let x=skyX; x<skyX+20; x++) for(let y=15; y<25; y++) if(Math.random()>0.2) this.world[y][x] = IDS.CLOUD;
        this.world[14][skyX+10] = IDS.CHEST;
        for(let i=0; i<10; i++) {
            let cx = Math.floor(Math.random()*(CHUNK_WIDTH-20))+10; let cy = Math.floor(hMap[cx] + 10 + Math.random()*50);
            if(this.world[cy][cx]===IDS.AIR && PROPS[this.world[cy+1][cx]].solid) this.world[cy][cx] = IDS.CHEST;
        }
        this.player.x = (CHUNK_WIDTH/2)*32; this.player.y = (hMap[Math.floor(CHUNK_WIDTH/2)]-5)*32;
        this.enemies.push(new Entity(this.player.x + 100, this.player.y, 'npc_guide'));

        this.generateAbandonedHouse(hMap);
        this.generateTreasureVault();

        this.calcLight();
    }

    isAreaFlat(x, y, range, hMap) {
        if (x - range < 0 || x + range >= CHUNK_WIDTH) return false;
        const groundY = hMap[x];
        for (let i = x - range; i <= x + range; i++) {
            if (Math.abs(hMap[i] - groundY) > 2) return false; // Too bumpy
            if (this.world[Math.floor(hMap[i]) - 1][i] !== IDS.AIR || this.world[Math.floor(hMap[i]) - 2][i] !== IDS.AIR) return false; // Trees in the way
        }
        return true;
    }

    generateAbandonedHouse(hMap) {
        const minX = Math.floor(CHUNK_WIDTH * 0.2);
        const maxX = Math.floor(CHUNK_WIDTH * 0.8);
        const searchAttempts = 50;

        for (let i = 0; i < searchAttempts; i++) {
            const x = minX + Math.floor(Math.random() * (maxX - minX));
            const y = Math.floor(hMap[x]);

            if (this.isAreaFlat(x, y, 10, hMap)) {
                const w = 8 + Math.floor(Math.random() * 5);
                const h = 5 + Math.floor(Math.random() * 3);
                const startX = x - Math.floor(w / 2);
                const startY = y - h;

                for (let j = startY; j < y; j++) {
                    for (let k = startX; k < startX + w; k++) {
                        if (k >= 0 && k < CHUNK_WIDTH && j >= 0 && j < CHUNK_HEIGHT) {
                           this.world[j][k] = IDS.AIR;
                           this.walls[j][k] = IDS.WOOD_WALL;
                        }
                    }
                }

                for (let k = startX; k < startX + w; k++) {
                    if (this.world[y][k] === IDS.AIR) this.world[y][k] = IDS.WOOD; // Floor
                    this.world[startY][k] = IDS.WOOD; // Roof
                }
                for (let j = startY; j < y; j++) {
                    this.world[j][startX] = IDS.WOOD;
                    this.world[j][startX + w - 1] = IDS.WOOD;
                }

                this.world[y - 1][startX + w - 3] = IDS.CHEST_HOUSE;
                this.world[y - 1][startX + 2] = IDS.WORKBENCH;

                if (Math.random() < 0.7) this.world[startY][startX + Math.floor(w/2)] = IDS.AIR;
                if (Math.random() < 0.5) this.walls[y - 2][startX + 3] = IDS.AIR;

                return;
            }
        }
    }

    genPool(x, y) { for(let py=y; py<y+5; py++) for(let px=x-5; px<x+5; px++) if(px>0 && px<CHUNK_WIDTH && py>0 && py<CHUNK_HEIGHT) if(this.world[py][px] === IDS.AIR) this.world[py][px] = IDS.WATER; }
    genTree(x,y) { for(let i=1;i<5;i++) this.world[y-i][x]=IDS.WOOD; this.world[y-5][x]=IDS.LEAVES; this.world[y-5][x-1]=IDS.LEAVES; this.world[y-5][x+1]=IDS.LEAVES; this.world[y-6][x]=IDS.LEAVES; }
    worm(x,y,l) {
        let d=Math.random()*6.28;
        for(let i=0;i<l;i++) {
            x+=Math.cos(d); y+=Math.sin(d); d+=(Math.random()-0.5)*0.5; let r=2;
            for(let cy=y-r; cy<y+r; cy++) for(let cx=x-r; cx<x+r; cx++) {
                let ix=Math.floor(cx), iy=Math.floor(cy);
                if(ix>0&&ix<CHUNK_WIDTH-1&&iy>0&&iy<CHUNK_HEIGHT-1) if(this.world[iy][ix]!==IDS.BEDROCK && this.world[iy][ix]!==IDS.CHEST && this.world[iy][ix]!==IDS.WATER) this.world[iy][ix]=IDS.AIR;
            }
        }
    }
    calcLight() {
        let q=[]; let day=(this.time/this.dayLen>0.2 && this.time/this.dayLen<0.8)?1.0:0.1;
        for(let y=0;y<CHUNK_HEIGHT;y++) for(let x=0;x<CHUNK_WIDTH;x++) {
            this.light[y][x]=0;
            if(y<CHUNK_HEIGHT*0.6 && this.world[y][x]===IDS.AIR && this.walls[y][x]===IDS.AIR) this.light[y][x]=day;
            let p=PROPS[this.world[y][x]]; if(p && p.light) this.light[y][x]=1;
            if(this.light[y][x]>0) q.push({x,y,l:this.light[y][x]});
        }
        let h=0; const d=[[0,1],[0,-1],[1,0],[-1,0]];
        while(h<q.length) {
            let c=q[h++]; if(c.l<=0.05) continue;
            for(let n of d) {
                let nx=c.x+n[0], ny=c.y+n[1];
                if(nx>=0&&nx<CHUNK_WIDTH&&ny>=0&&ny<CHUNK_HEIGHT) {
                    let dec=0.05; 
                    if(!PROPS[this.world[ny][nx]].transparent) dec=0.3; else if(this.walls[ny][nx]!==IDS.AIR) dec=0.1;
                    if(this.world[ny][nx]===IDS.WATER) dec+=0.1;
                    if(c.l-dec > this.light[ny][nx]) { this.light[ny][nx]=c.l-dec; q.push({x:nx,y:ny,l:c.l-dec}); }
                }
            }
        }
        this.updLight=false;
    }

    interact() {
        let npc = this.enemies.find(e => e.friendly && Math.hypot(e.x - this.player.x, e.y - this.player.y) < 60);
        if(npc) {
            const msgs = ["Guide: Greetings!", "Guide: Press [H] to check housing.", "Guide: Need a Workbench?", "Guide: Torches are essential.", "Guide: Build a house for me!", "Guide: Press [F5] to save."];
            this.log(msgs[Math.floor(Math.random()*msgs.length)]);
        } else { this.toggleCraft(); }
    }

    checkHousing(silent = false) {
        const px = Math.floor((this.player.x + this.player.w/2) / TILE_SIZE), py = Math.floor((this.player.y + this.player.h/2) / TILE_SIZE);
        let q = [{x:px, y:py}], visited = new Set([`${px},${py}`]), tiles = 0, walls = 0, lights = 0, doors = 0, enclosed = true;
        while(q.length > 0) {
            let c = q.shift(); tiles++; if(tiles > 200) { enclosed = false; break; }
            if(this.walls[c.y][c.x] !== IDS.AIR) walls++;
            if(PROPS[this.world[c.y][c.x]] && PROPS[this.world[c.y][c.x]].light) lights++;
            if(this.world[c.y][c.x] === IDS.DOOR_CLOSED || this.world[c.y][c.x] === IDS.DOOR_OPEN) doors++;
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
                let nx=c.x+d[0], ny=c.y+d[1];
                if(nx>=0&&nx<CHUNK_WIDTH&&ny>=0&&ny<CHUNK_HEIGHT) {
                    if(!visited.has(`${nx},${ny}`)) {
                        if(PROPS[this.world[ny][nx]].solid && this.world[ny][nx]!==IDS.PLATFORM && !this.world[ny][nx].toString().startsWith('2')) {} else { visited.add(`${nx},${ny}`); q.push({x:nx, y:ny}); }
                    }
                } else { enclosed = false; }
            });
        }

        const log = (msg) => { if (!silent) this.log(msg); };

        if(!enclosed) { log("Housing: Not enclosed."); return false; }
        if(tiles < 30) { log("Housing: Too small."); return false; }
        if(doors === 0) { log("Housing: No door."); return false; }
        if(lights === 0) { log("Housing: No light."); return false; }
        if(walls < tiles * 0.8) { log("Housing: Missing walls."); return false; }

        log("Housing: Suitable!");
        return true;
    }

    jump() {
        const p = this.player;
        if(p.grounded) { p.vy = -JUMP_FORCE; p.grounded=false; this.sound.play('jump'); }
        else if(p.canDoubleJump && p.jumps < 1) {
            p.vy = -JUMP_FORCE; p.jumps++;
            for(let i=0;i<5;i++) this.parts.push(new Particle(p.x+10, p.y+30, '#fff', 2));
            this.sound.play('jump');
        }
    }

    clickL() {
        const p=this.player, it=p.inv[p.sel], ip=PROPS[it.id];
        if(!ip) return;
        if(ip.type==='use') {
            if(ip.effect==='heal'&&p.hp<p.maxHp) { p.hp=Math.min(p.hp+ip.val, p.maxHp); this.consItem(); this.texts.push(new TextEffect(p.x,p.y,`+${ip.val}`,'#0f0')); }
            if(ip.effect==='maxhp'&&p.maxHp<400) { p.maxHp+=ip.val; p.hp+=ip.val; this.consItem(); this.texts.push(new TextEffect(p.x,p.y,'Max HP UP!','#e91e63')); }
            this.uiUpd(); return;
        }
        if(ip.type==='summon') { 
            if(this.time/this.dayLen<0.2 || this.time/this.dayLen>0.8) {
                this.enemies.push(new Entity(p.x, p.y-300, 'boss')); this.consItem(); this.log("The Eye Awakens!");
            } else this.log("Only at night...");
            return;
        }
        if(ip.type==='magic') {
            if(p.mana >= ip.mana) {
                p.mana -= ip.mana;
                let mx=this.mouse.x+this.cam.x, my=this.mouse.y+this.cam.y;
                let ang=Math.atan2(my-(p.y+16), mx-(p.x+10));
                this.projs.push(new Projectile(p.x+10, p.y+16, Math.cos(ang)*8, Math.sin(ang)*8, ip.damage, ip.color));
                this.uiUpd();
                this.sound.play('dig'); // Magic sound placeholder
            }
            return;
        }
        if(ip.type==='weapon') { p.swing=15; this.sound.play('swing'); }
        else if(ip.type==='tool') {
            let mx=this.mouse.x+this.cam.x, my=this.mouse.y+this.cam.y;
            let gx=Math.floor(mx/32), gy=Math.floor(my/32);
            if(gx<0||gx>=CHUNK_WIDTH||gy<0||gy>=CHUNK_HEIGHT) return;
            if(Math.hypot(gx*32+16-(p.x+10), gy*32+16-(p.y+18)) < REACH_PX) {
                let t=this.world[gy][gx];
                if(t!==IDS.AIR && PROPS[t].hardness!=Infinity) {
                    let req = PROPS[t].minPower || 0;
                    if(ip.power >= req) {
                        let dur = PROPS[t].hardness/ip.power;
                        if(this.mining.x!=gx||this.mining.y!=gy) this.mining={on:true,x:gx,y:gy,t:performance.now(),dur:dur};
                        if(performance.now()-this.mining.t > dur) {
                            let drop = t;
                            if(t===IDS.CHEST) drop=IDS.CHEST_ITEM;
                            if(t===IDS.HEART_CRYSTAL) drop=IDS.HEART_ITEM;
                            if(t===IDS.MUSHROOM || t===IDS.GLOWING_MUSHROOM) drop = (t===IDS.MUSHROOM) ? IDS.MUSHROOM_ITEM : IDS.GLOWING_MUSHROOM_ITEM;
                            if(t===IDS.SAND) drop=IDS.SAND_ITEM; if(t===IDS.CACTUS) drop=IDS.CACTUS_ITEM;
                            this.addItem(drop,1); this.world[gy][gx]=IDS.AIR; 
                            for(let i=0;i<8;i++) this.parts.push(new Particle(gx*32+16, gy*32+16, PROPS[t].color, 5));
                            this.updLight=true; this.mining.on=false;
                            this.sound.play('dig');
                            if(Math.random()<0.3) this.sound.play('pickup');
                        }
                    } else { if(Math.random()<0.1) this.texts.push(new TextEffect(gx*32, gy*32, "Too Hard!", "#aaa")); }
                }
            }
        }
    }
    clickR() {
        let mx=this.mouse.x+this.cam.x, my=this.mouse.y+this.cam.y;
        let gx=Math.floor(mx/32), gy=Math.floor(my/32);
        if(gx<0||gx>=CHUNK_WIDTH||gy<0||gy>=CHUNK_HEIGHT) return;
        if(Math.hypot(gx*32+16-(this.player.x+10), gy*32+16-(this.player.y+18)) > REACH_PX) return;
        let t=this.world[gy][gx];
        if(t===IDS.CHEST || t===IDS.CHEST_HOUSE || t === IDS.CHEST_VAULT) {
            this.world[gy][gx] = IDS.CHEST_EMPTY;
            let loots = [];
            if (t === IDS.CHEST_HOUSE) {
                let r = Math.random();
                if (r < 0.33) loots.push({id: IDS.IRON_SWORD, n: 1, name: "Old Sword"});
                else if (r < 0.66) loots.push({id: IDS.IRON_ARMOR, n: 1, name: "Old Armor"});
                else loots.push({id: IDS.BOOTS, n: 1, name: "Travel Boots"});
                if (Math.random() < 0.5) loots.push({id: IDS.IRON_BAR, n: 5 + Math.floor(Math.random()*5), name: "Iron Bars"});
            } else if (t === IDS.CHEST_VAULT) {
                let r = Math.random();
                if (r < 0.33) loots.push({id: IDS.GOLD_SWORD, n: 1, name: "Gilded Sword"});
                else if (r < 0.66) loots.push({id: IDS.GOLD_ARMOR, n: 1, name: "Gilded Armor"});
                else loots.push({id: IDS.CLOUD_BOTTLE, n: 1, name: "Cloud in a Bottle"});
                if (Math.random() < 0.7) loots.push({id: IDS.GOLD_BAR, n: 8 + Math.floor(Math.random()*8), name: "Gold Bars"});
            } else { // Normal chest
                let r = Math.random();
                if(r<0.25) loots.push({id: IDS.BOOTS, n: 1, name: "Hermes Boots"});
                else if(r<0.5) loots.push({id: IDS.CLOUD_BOTTLE, n: 1, name: "Cloud in a Bottle"});
                else if(r<0.75) loots.push({id: IDS.MAGIC_STAFF, n: 1, name: "Magic Staff"});
                else loots.push({id: IDS.GOLD_BAR, n: 5, name: "Gold Bars"});
            }

            if (loots.length > 0) {
                let foundMsg = "Found: ";
                loots.forEach((l, index) => {
                    this.addItem(l.id, l.n);
                    foundMsg += `${l.name}` + (index < loots.length - 1 ? ', ' : '');
                });
                this.log(foundMsg);
            }
            return;
        }
        if(t===IDS.DOOR_CLOSED) { this.world[gy][gx]=IDS.DOOR_OPEN; this.sound.play('dig'); return; }
        if(t===IDS.DOOR_OPEN) { this.world[gy][gx]=IDS.DOOR_CLOSED; this.sound.play('dig'); return; }

        let it=this.player.inv[this.player.sel], ip=PROPS[it.id];
        if(!ip || it.n<=0) return;
        if(ip.type==='acc') {
            if(it.id===IDS.BOOTS && !this.player.hasBoots) { this.player.hasBoots=true; this.log("Equipped Boots!"); this.consItem(); }
            else if(it.id===IDS.CLOUD_BOTTLE && !this.player.canDoubleJump) { this.player.canDoubleJump=true; this.log("Equipped Cloud!"); this.consItem(); }
            return;
        }
        if(ip.type==='armor') {
            let old = this.player.armor; this.player.armor = it.id; this.consItem();
            if(old) this.addItem(old, 1); this.calcDef(); return;
        }
        let pid = ip.placeId || it.id;
        if(ip.isWall) { if(this.world[gy][gx]===IDS.AIR && this.walls[gy][gx]!==pid) { this.walls[gy][gx]=pid; this.consItem(); this.updLight=true; this.sound.play('dig'); } }
        else if(ip.solid || ip.decor) {
            if(this.world[gy][gx]===IDS.AIR || this.world[gy][gx]===IDS.WATER) {
                if(ip.solid && !ip.platform && this.rectCol(gx*32,gy*32,32,32, this.player.x,this.player.y,this.player.w,this.player.h)) return;
                this.world[gy][gx]=pid; this.consItem(); this.updLight=true; this.sound.play('dig');
            }
        }
    }
    
    calcDef() { this.player.def = 0; if(this.player.armor) this.player.def = PROPS[this.player.armor].def; this.uiUpd(); }
    rectCol(x1,y1,w1,h1, x2,y2,w2,h2) { return x1<x2+w2 && x1+w1>x2 && y1<y2+h2 && y1+h1>y2; }
    createPart(gx,gy,c) { for(let i=0;i<5;i++) this.parts.push(new Particle(gx*32+16, gy*32+16, c, 4)); }
    consItem() {
        let s = this.player.inv[this.player.sel];
        if(s.id !== IDS.AIR && s.n > 0) {
             s.n--;
             if(s.n <= 0) { s.id = IDS.AIR; s.n = 0; }
             this.uiUpd();
        }
    }
    addItem(id, n) {
        if(n > 0) {
            let p = PROPS[id];
            let max = (p && p.maxStack) ? p.maxStack : 999;
            while(n > 0) {
                let s = this.player.inv.find(i => i.id === id && i.n < max);
                if(s) {
                    let add = Math.min(n, max - s.n);
                    s.n += add; n -= add;
                } else {
                    let e = this.player.inv.find(i => i.id === IDS.AIR);
                    if(e) {
                        let add = Math.min(n, max);
                        e.id = id; e.n = add; n -= add;
                    } else break;
                }
            }
        } else {
            let s = this.player.inv.find(i=>i.id===id);
            if(s) { s.n+=n; if(s.n<=0) {s.id=IDS.AIR; s.n=0;} }
        }
        this.uiUpd();
    }
    toggleCraft() { this.ui.craft=!this.ui.craft; document.getElementById('crafting-menu').style.display=this.ui.craft?'block':'none'; if(this.ui.craft) this.rendRec(); }
    _canCraft(recipe, nearbyStations) {
        const hasMaterials = recipe.in.every(m => {
            const total = this.player.inv
                .filter(i => i.id === m.id)
                .reduce((sum, i) => sum + i.n, 0);
            return total >= m.n;
        });
        if (!hasMaterials) return false;

        if (recipe.station && !nearbyStations.includes(recipe.station)) return false;

        return true;
    }
    rendRec() {
        let l=document.getElementById('recipe-list'); l.innerHTML='';
        let cx=Math.floor((this.player.x+10)/32), cy=Math.floor((this.player.y+18)/32);
        let stations=[]; for(let y=cy-3;y<=cy+3;y++)for(let x=cx-3;x<=cx+3;x++) if(x>=0&&x<CHUNK_WIDTH&&y>=0&&y<CHUNK_HEIGHT && PROPS[this.world[y][x]] && PROPS[this.world[y][x]].station) stations.push(this.world[y][x]);
        RECIPES.forEach(r=>{
            const can = this._canCraft(r, stations);
            let txt="";
            r.in.forEach(m=>{ txt+=`${PROPS[m.id].name} x${m.n} `; });
            let d=document.createElement('div'); d.className='recipe'+(can?'':' disabled');
            d.innerHTML=`<div class="recipe-icon" style="background:${PROPS[r.out.id].color}"></div><div class="recipe-details"><div><b>${PROPS[r.out.id].name}</b> x${r.out.n}</div><div style="color:#aaa">${txt}</div></div>`;
            d.onclick=()=>{ if(can) { r.in.forEach(m=>this.addItem(m.id,-m.n)); this.addItem(r.out.id, r.out.n); this.rendRec(); } };
            l.appendChild(d);
        });
    }
    uiUpd() {
        let b=document.getElementById('hotbar'); b.innerHTML='';
        // Only show first 9 in hotbar
        for(let i=0; i<9; i++) {
            let s = this.player.inv[i];
            let d=document.createElement('div'); d.className='slot'+(i===this.player.sel?' active':''); d.onclick=()=>{this.player.sel=i;this.uiUpd();};
            if(s.id!==IDS.AIR) {
                let p=PROPS[s.id]; let ic=document.createElement('div'); ic.className='item-icon';
                if(p.type==='tool') ic.className+=' icon-pickaxe'; else if(p.type==='weapon') ic.className+=' icon-sword'; else if(p.type==='acc') ic.className+=' icon-acc'; else if(p.type==='armor') ic.className+=' icon-armor'; else if(p.type==='magic') { ic.style.background=p.color; ic.style.borderRadius='50%'; ic.style.border='2px solid #fff'; } else { ic.style.backgroundColor=p.color; if(p.decor==='torch') { ic.style.width='6px'; ic.style.height='14px'; ic.style.borderBottom='2px solid brown'; } }
                d.appendChild(ic); if(p.maxStack!==1) { let c=document.createElement('div'); c.className='item-count'; c.innerText=s.n; d.appendChild(c); }
            }
            let n=document.createElement('div'); n.className='slot-num'; n.innerText=i+1; d.appendChild(n); b.appendChild(d);
        }
        let el=document.getElementById('equip-icon'); el.innerHTML='';
        if(this.player.armor) { let p=PROPS[this.player.armor]; let ic=document.createElement('div'); ic.className='item-icon icon-armor'; ic.style.backgroundColor=p.color; el.appendChild(ic); }
        let hr=document.getElementById('hearts-row'); hr.innerHTML=''; let mr=document.getElementById('mana-row'); mr.innerHTML='';
        let nh=Math.ceil(this.player.maxHp/20), ch=Math.ceil(this.player.hp/20);
        for(let i=0;i<nh;i++) { let h=document.createElement('div'); h.className='heart'+(i<ch?'':' empty'); hr.appendChild(h); }
        let nm=Math.ceil(this.player.maxMana/20), cm=Math.ceil(this.player.mana/20);
        for(let i=0;i<nm;i++) { let s=document.createElement('div'); s.className='star'+(i<cm?'':' empty'); mr.appendChild(s); }
        document.getElementById('def-display').innerText = `Defense: ${this.player.def}`;
        if(this.ui.craft) this.rendRec();
        if(this.ui.inv) this.renderInventoryScreen();
    }

    update() {
        if(this.hitStop > 0) { this.hitStop--; return; } 
        this.time++; if(this.time>=this.dayLen) this.time=0;
        if(this.time%60===0) { 
            this.updLight=true; 
            if(this.player.mana<this.player.maxMana) { this.player.mana++; this.uiUpd(); } 
            // Minimap update occasionally
            this.drawMinimap();
        }
        let isNight = this.time/this.dayLen<0.2 || this.time/this.dayLen>0.8;
        
        if(this.enemies.length< (isNight?8:4) && Math.random()<0.01) {
            let ex=Math.floor(this.player.x/32) + (Math.random()>0.5?25:-25);
            if(ex>0&&ex<CHUNK_WIDTH) {
                let type='slime', tile = this.world[Math.floor(this.player.y/32)][ex];
                if(tile===IDS.EBONSTONE || this.world[Math.floor(this.player.y/32)+5][ex]===IDS.EBONSTONE) type='eater'; else if(isNight) type=Math.random()>0.5?'zombie':'eye';
                let ey=0; while(ey<CHUNK_HEIGHT && !PROPS[this.world[ey][ex]].solid) ey++;
                if(type==='eye'||type==='eater') ey = Math.floor(this.player.y/32)-10;
                if(ey<CHUNK_HEIGHT) this.enemies.push(new Entity(ex*32, (ey-2)*32, type));
            }
        }

        let p=this.player;
        let speed = p.hasBoots ? PLAYER_SPEED * 1.5 : PLAYER_SPEED;
        if(this.keys['KeyA']) { p.vx=-speed; p.dir=-1; p.frame+=0.2; } else if(this.keys['KeyD']) { p.vx=speed; p.dir=1; p.frame+=0.2; } else { p.vx*=0.8; p.frame=0; }
        
        let tileAt = this.world[Math.floor((p.y+p.h/2)/TILE_SIZE)][Math.floor((p.x+p.w/2)/TILE_SIZE)];
        let inWater = tileAt === IDS.WATER;
        if(inWater) { p.vx *= 0.8; p.vy += 0.1; if(p.vy>2) p.vy=2; if(this.keys['Space']) p.vy = -3; } else { p.vy+=GRAVITY; if(p.vy>TERMINAL_VELOCITY) p.vy=TERMINAL_VELOCITY; }

        p.x+=p.vx; this.collide(p, true);
        p.y+=p.vy; if(p.grounded) p.jumps=0; p.grounded=false; this.collide(p, false);
        if(p.x<0) p.x=0; if(p.y>CHUNK_HEIGHT*32) { p.hp=0; p.hit(0); }
        this.cam.x += (p.x - this.w/2 - this.cam.x)*0.1;
        this.cam.y += (p.y - this.h/2 - this.cam.y)*0.1;

        if(p.invin>0) p.invin--;
        if(p.swing>0) { p.swing--; if(p.swing===5) this.meleeAttack(); }
        if(this.mouse.l) this.clickL();

        this.enemies=this.enemies.filter(e=>!e.dead);
        this.enemies.forEach(e=>e.update(this.world, p, this.parts, this.texts, isNight, this));
        this.projs=this.projs.filter(pr=>!pr.dead);
        this.projs.forEach(pr=>pr.update(this.world, this.enemies, this.parts, this.texts, this));
        this.parts.forEach(pt=>pt.update()); this.parts=this.parts.filter(pt=>pt.life>0);
        this.texts.forEach(t=>t.update()); this.texts=this.texts.filter(t=>t.life>0);

        if(this.updLight) this.calcLight();

        this.checkObjectiveCompletion();
        
        p.hit = (dmg) => {
            if(p.invin>0) return;
            let actual = Math.max(1, dmg - p.def);
            p.hp-=actual; p.invin=60; p.vy=-4;
            this.hitStop = 10; 
            this.texts.push(new TextEffect(p.x, p.y, -actual, 'red')); this.uiUpd();
            if(p.hp<=0) { p.hp=p.maxHp; p.x=p.respawn.x; p.y=p.respawn.y; p.vx=0; p.vy=0; }
        };
    }
    
    collide(obj, isX) {
        let l=Math.floor(obj.x/32), r=Math.floor((obj.x+obj.w)/32), t=Math.floor(obj.y/32), b=Math.floor((obj.y+obj.h)/32);
        
        // Helper to safely get props
        const getP = (x,y) => {
            if(x>=0 && x<CHUNK_WIDTH && y>=0 && y<CHUNK_HEIGHT) return PROPS[this.world[y][x]];
            return null;
        };
        
        if (isX) {
            for (let y = t; y <= b; y++) {
                // For horizontal, platforms are NOT solid.
                // Check strictly solid blocks.
                let pR = getP(r, y);
                if (obj.vx > 0 && pR && pR.solid) {
                    obj.x = r * 32 - obj.w - 0.1;
                    obj.vx = 0;
                    break;
                }
                let pL = getP(l, y);
                if (obj.vx < 0 && pL && pL.solid) {
                    obj.x = (l + 1) * 32 + 0.1;
                    obj.vx = 0;
                    break;
                }
            }
        } else {
            if(obj.vy>0) {
                // Feet check
                let pL = getP(l,b), pR = getP(r,b);
                // Check true solid
                if((pL&&pL.solid) || (pR&&pR.solid)) {
                    if(obj.y+obj.h <= b*32+12) { obj.y=b*32-obj.h; obj.vy=0; obj.grounded=true; return; }
                }
                // Check platform
                if((pL&&pL.platform) || (pR&&pR.platform)) {
                    if(obj.y+obj.h <= b*32+12 && !this.keys['KeyS']) { obj.y=b*32-obj.h; obj.vy=0; obj.grounded=true; }
                }
            }
            else if(obj.vy<0) {
                // Head check
                let pL = getP(l,t), pR = getP(r,t);
                if((pL&&pL.solid) || (pR&&pR.solid)) { obj.y=(t+1)*32; obj.vy=0; }
            }
        }
    }
    meleeAttack() {
        let p=this.player; let cx=p.x+p.w/2+p.dir*20, cy=p.y+p.h/2;
        let dmg = PROPS[p.inv[p.sel].id].damage || 5;
        this.enemies.forEach(e=>{ if(!e.friendly && Math.abs(e.x+e.w/2 - cx)<40 && Math.abs(e.y+e.h/2 - cy)<40) e.takeDamage(dmg, p.x, this.parts, this.texts, this); });
    }

    draw() {
        let cyc=this.time/this.dayLen;
        let r=135,g=206,b=235; if(cyc<0.2||cyc>0.8) {r=20,g=20,b=40;} else if(cyc<0.25||cyc>0.75) {r=200,g=100,b=50;}
        this.ctx.fillStyle=`rgb(${r},${g},${b})`; this.ctx.fillRect(0,0,this.w,this.h);
        this.ctx.fillStyle=`rgba(${r*0.6},${g*0.6},${b*0.6},0.6)`; this.ctx.beginPath();
        for(let i=0;i<=this.w;i+=10) { let h=100+Math.sin((i+this.cam.x*0.3)*0.01)*50; this.ctx.lineTo(i, this.h-h); }
        this.ctx.lineTo(this.w,this.h); this.ctx.lineTo(0,this.h); this.ctx.fill();

        this.ctx.save(); this.ctx.translate(-Math.floor(this.cam.x), -Math.floor(this.cam.y));

        const drawSpriteIfReady = (props, dx, dy) => {
            const activeTileset = getActiveTileset();
            if(activeTileset.ready && props && props.sprite) {
                this.ctx.drawImage(activeTileset.img, props.sprite.x*TILE_SIZE, props.sprite.y*TILE_SIZE, TILE_SIZE, TILE_SIZE, dx, dy, TILE_SIZE, TILE_SIZE);
                return true;
            }
            return false;
        };

        let x0=Math.floor(this.cam.x/32), x1=x0+Math.ceil(this.w/32)+1, y0=Math.floor(this.cam.y/32), y1=y0+Math.ceil(this.h/32)+1;
        for(let y=Math.max(0,y0); y<Math.min(CHUNK_HEIGHT,y1); y++) for(let x=Math.max(0,x0); x<Math.min(CHUNK_WIDTH,x1); x++) {
            let t=this.world[y][x], w=this.walls[y][x], l=this.light[y][x], px=x*32, py=y*32;
            if(w!==IDS.AIR && (t===IDS.AIR || PROPS[t].transparent)) {
                const wp=PROPS[w];
                const wallUsedSprite = drawSpriteIfReady(wp, px, py);
                if(!wallUsedSprite) { this.ctx.fillStyle=wp.color; this.ctx.fillRect(px,py,32,32); }
                this.ctx.fillStyle='rgba(0,0,0,0.3)'; this.ctx.fillRect(px,py,32,32);
            }
            if(t!==IDS.AIR) {
                let p=PROPS[t];
                const usedSprite = drawSpriteIfReady(p, px, py);
                if(!usedSprite) {
                    this.ctx.fillStyle=p.color;
                    if(p.decor) {
                        if(p.decor==='torch') { this.ctx.fillStyle='brown'; this.ctx.fillRect(px+14,py+10,4,10); this.ctx.fillStyle='orange'; this.ctx.fillRect(px+12,py+6,8,8); }
                        else if(p.decor==='platform') this.ctx.fillRect(px,py,32,8);
                        else if(p.decor==='chest') { this.ctx.fillStyle='#fbc02d'; this.ctx.fillRect(px+2,py+10,28,22); this.ctx.fillStyle='#000'; this.ctx.fillRect(px+14,py+18,4,4); }
                        else if(p.decor.startsWith('door')) { if(p.decor==='door_c') this.ctx.fillRect(px,py,8,32); else this.ctx.fillRect(px,py,32,8); }
                        else if(p.decor==='heart') { this.ctx.fillStyle='#e91e63'; this.ctx.beginPath(); this.ctx.arc(px+16,py+16,8,0,6.28); this.ctx.fill(); }
                        else if(p.decor==='mushroom') { this.ctx.fillStyle='#f44336'; this.ctx.beginPath(); this.ctx.arc(px+16,py+10,10,3.14,0); this.ctx.fill(); this.ctx.fillStyle='#fff'; this.ctx.fillRect(px+12,py+16,8,16); }
                        else if(p.decor==='mushroom_blue') { this.ctx.fillStyle='#00e5ff'; this.ctx.beginPath(); this.ctx.arc(px+16,py+10,10,3.14,0); this.ctx.fill(); this.ctx.fillStyle='#fff'; this.ctx.fillRect(px+12,py+16,8,16); }
                        else if(p.decor==='demonite') { this.ctx.fillRect(px,py,32,32); this.ctx.fillStyle='rgba(200,0,255,0.4)'; this.ctx.fillRect(px+4,py+4,6,6); }
                        else if(p.decor==='hell') { this.ctx.fillRect(px,py,32,32); this.ctx.fillStyle='#f00'; this.ctx.fillRect(px+4,py+4,6,6); }
                        else if(p.decor==='cactus') { this.ctx.fillStyle='#43a047'; this.ctx.fillRect(px+8,py,16,32); }
                        else { this.ctx.fillRect(px,py,32,32); this.ctx.fillStyle='rgba(255,255,255,0.3)'; this.ctx.fillRect(px+4,py+4,6,6); }
                    } else {
                         // Procedural block rendering for non-decor blocks
                        switch (t) {
                            case IDS.DIRT:
                                this.ctx.fillStyle = p.color;
                                this.ctx.fillRect(px, py, 32, 32);
                                let rand = mulberry32(px * 13 + py * 59);
                                for (let i = 0; i < 15; i++) {
                                    this.ctx.fillStyle = `rgba(0,0,0,${rand() * 0.15})`;
                                    this.ctx.fillRect(px + rand() * 30, py + rand() * 30, 2, 2);
                                }
                                break;
                            case IDS.GRASS:
                            case IDS.PURPLE_GRASS:
                            case IDS.MUSHROOM_GRASS:
                                let baseColor = (t === IDS.MUSHROOM_GRASS) ? PROPS[IDS.MUD].color : PROPS[IDS.DIRT].color;
                                this.ctx.fillStyle = baseColor;
                                this.ctx.fillRect(px, py, 32, 32);
                                const grad = this.ctx.createLinearGradient(px, py, px, py + 8);
                                grad.addColorStop(0, p.topColor);
                                grad.addColorStop(1, p.color);
                                this.ctx.fillStyle = grad;
                                this.ctx.fillRect(px, py, 32, 8);
                                break;
                            case IDS.STONE:
                                this.ctx.fillStyle = p.color;
                                this.ctx.fillRect(px, py, 32, 32);
                                this.ctx.strokeStyle = 'rgba(0,0,0,0.3)'; this.ctx.lineWidth = 1;
                                this.ctx.beginPath(); this.ctx.moveTo(px+5,py+2); this.ctx.lineTo(px+20, py+28); this.ctx.stroke();
                                this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                                this.ctx.beginPath(); this.ctx.moveTo(px+7,py+2); this.ctx.lineTo(px+22, py+28); this.ctx.stroke();
                                break;
                            case IDS.WOOD:
                                this.ctx.fillStyle = p.color;
                                this.ctx.fillRect(px, py, 32, 32);
                                this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                                this.ctx.fillRect(px + 4, py, 5, 32); this.ctx.fillRect(px + 15, py, 3, 32); this.ctx.fillRect(px + 24, py, 4, 32);
                                break;
                            case IDS.LEAVES:
                                this.ctx.fillStyle = p.color;
                                this.ctx.fillRect(px, py, 32, 32);
                                let leafRand = mulberry32(px * 17 + py * 61);
                                for (let i = 0; i < 10; i++) {
                                    this.ctx.fillStyle = `rgba(0,0,0,${leafRand() * 0.2})`;
                                    this.ctx.beginPath();
                                    this.ctx.arc(px + leafRand() * 32, py + leafRand() * 32, leafRand() * 4 + 2, 0, Math.PI * 2);
                                    this.ctx.fill();
                                }
                                break;
                            default:
                                this.ctx.fillStyle = p.color;
                                this.ctx.fillRect(px, py, 32, 32);
                                break;
                        }
                    }
                }

                // Mining Crack
                if(this.mining.on && this.mining.x===x && this.mining.y===y) {
                    const progress = (performance.now() - this.mining.t) / this.mining.dur;
                    const stage = Math.floor(progress * 4);
                    this.ctx.strokeStyle='rgba(0,0,0,0.7)'; this.ctx.lineWidth=2; this.ctx.beginPath();
                    for(let i=0; i<=stage*2; i++) {
                        let ang = (x*7 + y*13 + i*1.5);
                        this.ctx.moveTo(px+16, py+16);
                        this.ctx.lineTo(px+16+Math.cos(ang)*14, py+16+Math.sin(ang)*14);
                    }
                    this.ctx.stroke();
                }
            }
            if(l<1) { this.ctx.fillStyle=`rgba(0,0,0,${1-l})`; this.ctx.fillRect(px,py,32,32); }
        }
        this.enemies.forEach(e=>e.draw(this.ctx,0,0)); this.projs.forEach(p=>p.draw(this.ctx,0,0));
        this.parts.forEach(p=>p.draw(this.ctx,0,0)); this.texts.forEach(t=>t.draw(this.ctx,0,0));
        
        let p=this.player, x=p.x, y=p.y;
        let anim=Math.sin(p.frame)*4;
        this.ctx.save(); if(p.dir===-1){this.ctx.translate(x+p.w/2, y+p.h/2); this.ctx.scale(-1,1); this.ctx.translate(-(x+p.w/2), -(y+p.h/2));}
        
        let armorColor = '#1e88e5'; let bodyColor = '#e53935';
        if(p.armor) {
            if(p.armor===IDS.WOOD_ARMOR) { armorColor='#5d4037'; bodyColor='#795548'; }
            if(p.armor===IDS.IRON_ARMOR) { armorColor='#78909c'; bodyColor='#b0bec5'; }
            if(p.armor===IDS.GOLD_ARMOR) { armorColor='#fbc02d'; bodyColor='#fff176'; }
            if(p.armor===IDS.SHADOW_ARMOR) { armorColor='#311b92'; bodyColor='#6200ea'; }
        }

        this.ctx.fillStyle=armorColor; this.ctx.fillRect(x+4+anim, y+22, 6,14); this.ctx.fillRect(x+10-anim, y+22, 6,14);
        this.ctx.fillStyle=bodyColor; this.ctx.fillRect(x, y+10, p.w, 14);
        this.ctx.fillStyle='#ffcc80'; this.ctx.fillRect(x+2, y-2, 16, 14);
        
        let it=p.inv[p.sel];
        if(it.id!==IDS.AIR) {
            this.ctx.translate(x+10, y+16); if(p.swing>0) this.ctx.rotate(((1-p.swing/15)*160-60)*0.017);
            let c=PROPS[it.id].color; this.ctx.fillStyle=c;
            if(PROPS[it.id].type==='tool'||PROPS[it.id].type==='weapon') { this.ctx.rotate(-0.78); this.ctx.fillRect(0,-2,20,4); }
            else if(PROPS[it.id].type==='magic') { this.ctx.fillStyle='#aa00ff'; this.ctx.fillRect(0,-2,18,4); this.ctx.fillStyle='#ffd700'; this.ctx.beginPath(); this.ctx.arc(18,0,4,0,6.28); this.ctx.fill(); }
            else this.ctx.fillRect(0,0,10,10);
        }
        this.ctx.restore();

        let mx=Math.floor((this.mouse.x+this.cam.x)/32), my=Math.floor((this.mouse.y+this.cam.y)/32);
        this.ctx.strokeStyle='rgba(255,255,255,0.5)'; this.ctx.lineWidth=2; this.ctx.strokeRect(mx*32, my*32, 32,32);
        this.ctx.restore();
    }
    loop() { this.update(); this.draw(); requestAnimationFrame(()=>this.loop()); }
}

// Replaced window.onload to add click-to-start requirement
window.onload = () => {
    document.getElementById('error-screen').addEventListener('click', () => {
        document.getElementById('error-screen').style.display = 'none';
    });

    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('test') === 'true') {
        runTests();
        return;
    }

    const startScreen = document.getElementById('start-screen');
    const startHandler = () => {
        startScreen.style.display = 'none';
        new Game();
        // Remove listener to prevent re-triggering
        startScreen.removeEventListener('click', startHandler);
    };
    startScreen.addEventListener('click', startHandler);
};

function runTests() {
    console.log("Running automated tests...");

    const TestSuite = {
        tests: [],
        total: 0,
        passed: 0,

        test(name, fn) {
            this.tests.push({ name, fn });
        },

        run() {
            console.log("Starting test run...");
            for (const { name, fn } of this.tests) {
                this.total++;
                try {
                    fn();
                    this.passed++;
                    console.log(`  [PASS] ${name}`);
                } catch (e) {
                    console.error(`  [FAIL] ${name}: ${e.message}\n${e.stack}`);
                }
            }
            this.summary();
            return this.passed === this.total;
        },

        assert(condition, message) {
            if (!condition) {
                throw new Error(message || "Assertion failed");
            }
        },

        assertEquals(a, b, message) {
            if (a !== b) {
                throw new Error(message || `Expected ${JSON.stringify(a)} to equal ${JSON.stringify(b)}`);
            }
        },

        assertDeepEquals(a, b, message) {
            if (JSON.stringify(a) !== JSON.stringify(b)) {
                throw new Error(message || `Expected ${JSON.stringify(a)} to deeply equal ${JSON.stringify(b)}`);
            }
        },

        summary() {
            console.log(`\nTest Summary: ${this.passed} / ${this.total} passed.`);
            const resultsDiv = document.createElement('div');
            resultsDiv.id = 'test-results';
            resultsDiv.dataset.passed = this.passed;
            resultsDiv.dataset.total = this.total;
            document.body.innerHTML = ''; // Clear body
            document.body.appendChild(resultsDiv);

            if (this.passed !== this.total) {
                console.error("Some tests failed.");
            } else {
                console.log("All tests passed!");
            }
        }
    };

    TestSuite.test("Horizontal Collision", () => {
        const collideFn = Game.prototype.collide;
        const mockGameInstance = {
            world: new Array(CHUNK_HEIGHT).fill(0).map(() => new Array(CHUNK_WIDTH).fill(IDS.AIR))
        };
        const collide = collideFn.bind(mockGameInstance);

        const wallX = 10;
        const wallY = 10;
        mockGameInstance.world[wallY + 1][wallX] = IDS.STONE;

        const player = {
            x: (wallX * TILE_SIZE) - 25,
            y: (wallY * TILE_SIZE) + 1,
            w: 20,
            h: 36,
            vx: 10,
            vy: 0
        };

        player.x += player.vx;
        collide(player, true);

        const correctedX = wallX * TILE_SIZE - player.w - 0.1;
        TestSuite.assert(Math.abs(player.x - correctedX) < 0.1, `Player penetrated wall. Expected X: ~${correctedX.toFixed(2)}, Got: ${player.x.toFixed(2)}`);
    });

    TestSuite.test("Inventory: addItem to empty slot", () => {
        const game = new Game();
        game.player.inv.forEach(s => {s.id=IDS.AIR; s.n=0;});
        game.addItem(IDS.WOOD, 10);
        TestSuite.assertDeepEquals(game.player.inv[0], {id:IDS.WOOD, n:10}, "Item not added to empty slot correctly.");
    });

    TestSuite.test("Inventory: addItem stacking", () => {
        const game = new Game();
        game.player.inv.forEach(s => {s.id=IDS.AIR; s.n=0;});
        game.player.inv[0] = {id:IDS.WOOD, n:5};
        game.addItem(IDS.WOOD, 10);
        TestSuite.assertEquals(game.player.inv[0].n, 15, "Item not stacked correctly.");
    });

    TestSuite.test("Inventory: addItem with full inventory", () => {
        const game = new Game();
        for (let i = 0; i < game.player.inv.length; i++) {
            game.player.inv[i] = {id: IDS.STONE, n: 1};
        }
        game.addItem(IDS.WOOD, 10);
        TestSuite.assert(game.player.inv.every(i => i.id !== IDS.WOOD), "Item added to a full inventory.");
    });

    TestSuite.test("Crafting: Can craft with materials", () => {
        const game = new Game();
        game.player.inv = [{id:IDS.WOOD, n:10}];
        const recipe = { in: [{id:IDS.WOOD, n:10}] };
        TestSuite.assert(game._canCraft(recipe, []), "Should be able to craft with enough materials.");
    });

    TestSuite.test("Crafting: Cannot craft without materials", () => {
        const game = new Game();
        game.player.inv = [{id:IDS.WOOD, n:5}];
        const recipe = { in: [{id:IDS.WOOD, n:10}] };
        TestSuite.assert(!game._canCraft(recipe, []), "Should not be able to craft without enough materials.");
    });

    TestSuite.test("Crafting: Cannot craft without station", () => {
        const game = new Game();
        game.player.inv = [{id:IDS.STONE, n:20}, {id:IDS.WOOD, n:5}, {id:IDS.TORCH, n:3}];
        const recipe = { in: [{id:IDS.STONE, n:20}, {id:IDS.WOOD, n:5}, {id:IDS.TORCH, n:3}], station: IDS.WORKBENCH };
        TestSuite.assert(!game._canCraft(recipe, []), "Should not be able to craft without the required station.");
    });

    TestSuite.test("Crafting: Can craft with materials in multiple stacks", () => {
        const game = new Game();
        game.player.inv = [{id:IDS.WOOD, n:5}, {id:IDS.WOOD, n:5}];
        const recipe = { in: [{id:IDS.WOOD, n:10}] };
        TestSuite.assert(game._canCraft(recipe, []), "Should be able to craft with materials from multiple stacks.");
    });

    TestSuite.test("Vertical Collision", () => {
        const game = new Game();
        const collide = game.collide.bind(game);
        const groundY = 10;
        game.world[groundY][10] = IDS.STONE;

        const player = {
            x: 10 * TILE_SIZE,
            y: (groundY - 3) * TILE_SIZE,
            w: 20,
            h: 36,
            vx: 0,
            vy: 60,
            grounded: false
        };

        player.y += player.vy;
        collide(player, false);

        const correctedY = groundY * TILE_SIZE - player.h;
        TestSuite.assert(Math.abs(player.y - correctedY) < 0.1, `Player fell through ground. Expected Y: ~${correctedY.toFixed(2)}, Got: ${player.y.toFixed(2)}`);
        TestSuite.assert(player.grounded, "Player should be grounded after collision.");
    });

    TestSuite.test("Combat: Player takes damage", () => {
        const game = new Game();
        game.player.hp = 100;
        game.player.def = 5;
        game.player.hit(20);
        TestSuite.assertEquals(game.player.hp, 85, "Damage not calculated correctly with defense.");
        TestSuite.assert(game.player.invin > 0, "Invincibility frames not applied after being hit.");
    });

    TestSuite.test("Tooltip: Healing item shows heal amount", () => {
        const game = new Game();
        const mushroom = PROPS[IDS.MUSHROOM_ITEM];
        const html = game._generateTooltipHTML(mushroom);
        TestSuite.assert(
            html.includes(`Restores ${mushroom.val} HP`),
            `Tooltip for healing item should include heal amount. Got: ${html}`
        );
    });

    return TestSuite.run();
}
</script>
</body>
</html>
